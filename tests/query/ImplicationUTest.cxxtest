/*
 * tests/query/ImplicationUTest.cxxtest
 *
 * Copyright (C) 2009 Linas Vepstas <linasvepstas@gmail.com>
 * All Rights Reserved
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License v3 as
 * published by the Free Software Foundation and including the exceptions
 * at http://opencog.org/wiki/Licenses
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program; if not, write to:
 * Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <opencog/atomspace/Link.h>
#include <opencog/atomspace/Node.h>
#include <opencog/guile/SchemeEval.h>
#include <opencog/guile/SchemeSmob.h>
#include <opencog/query/DefaultPatternMatchCB.h>
#include <opencog/query/PatternMatch.h>
#include <opencog/server/CogServer.h>
#include <opencog/util/Config.h>
#include <opencog/util/Logger.h>

using namespace opencog;

class ExecutionUTest :  public CxxTest::TestSuite
{
	private:
		PatternMatch pm;
		AtomSpace *as;
#ifdef HAVE_GUILE
		SchemeEval evaluator;
#endif
		Handle varscope;
		Handle implication, implication2;

	public:

		ExecutionUTest(void)
		{
			try
			{
				config().load("opencog-test.conf");
			}
			catch (RuntimeException &e)
			{
				std::cerr << e.getMessage() << std::endl;
			}
			logger().setFilename(config()["LOG_FILE"]);
			logger().setLevel(Logger::getLevelFromString(config()["LOG_LEVEL"]));
			logger().setPrintToStdoutFlag(config().get_bool("LOG_TO_STDOUT"));

			// logger().setLevel(Logger::DEBUG);
			// logger().setPrintToStdoutFlag(true);
		}

		~ExecutionUTest()
		{
			// erase the log file if no assertions failed
			if (!CxxTest::TestTracker::tracker().suiteFailed())
				std::remove(logger().getFilename().c_str());
		}

		void setUp(void);

		void tearDown(void) { }

		void test_exec(void);
};

/*
 * This function sets up an implication link, and some data.
 *
 * Note: although raw ImplicationLinks occuring outside of a
 * VarScopeLink are now deprecated, this test still tests that
 * function, since there's a fair amount of existing code that
 * still uses it.  At any rate, under the covers, both share a
 * code path, so its a good test no matter what.
 *
 * Several subsystems and functions are tested here:
 * 1) Use of scheme for specifying hypergraphs.
 * 2) Use of the scheme apply() method.
 * 3) Validation of the pattern-matching clauses, which are not
 *    supposed to contain constants (this tests explicitly includes
 *    some constants)
 * 4) Crisp-logic implication.
 * 5) Single-clause implications.
 * 6) Use of VariableScopeLink
 */
#define an as->addNode
#define al as->addLink
void ExecutionUTest::setUp(void)
{
	CogServer& cogserver = static_cast<CogServer&>(server());
	as = cogserver.getAtomSpace();
	pm.set_atomspace(as);

#ifdef HAVE_GUILE
	// Create initialzation
	const char * setup = 
	"(define (stv mean conf) (cog-new-stv mean conf))\n"
	"(define (AndLink . x)\n"
	"   (apply cog-new-link (append (list 'AndLink) x)))\n"
	"(define (ListLink . x)\n"
	"   (apply cog-new-link (append (list 'ListLink) x)))\n"
	"(define (InheritanceLink . x)\n"
	"   (apply cog-new-link (append (list 'InheritanceLink) x)))\n"
	"(define (ImplicationLink . x)\n"
	"   (apply cog-new-link (append (list 'ImplicationLink) x)))\n"
	"(define (DefinedFrameNode . x)\n"
	"   (apply cog-new-node (append (list 'DefinedFrameNode) x)))\n"
	"(define (PredicateNode . x)\n"
	"   (apply cog-new-node (append (list 'PredicateNode) x)))\n"
	"(define (VariableNode . x)\n"
	"   (apply cog-new-node (append (list 'VariableNode) x)))\n"
	"(define (VariableScopeLink . x)\n"
	"   (apply cog-new-link (append (list 'VariableScopeLink) x)))\n";
	evaluator.eval(setup);

	// Create an implication link that will be tested.
	const char * imp = 
	"(define (imp)\n"
	"(ImplicationLink\n"
	"   (AndLink\n"
	"      (InheritanceLink\n"
	"         (PredicateNode \"grab@a6460c2d-b5f8-4287-8882-028d12de42d2_Manipulation\")\n"
	"         (DefinedFrameNode \"#Manipulation\")\n"
	"      )\n"
	"      (InheritanceLink (stv 1 1)\n"
	"         (VariableNode \"$predNode\")\n"
	"         (DefinedFrameNode \"#Manipulation\")\n"
	"      )\n"
	"   )\n"
	"   (VariableNode \"$predNode\")\n"
	")\n"
	")\n";
	evaluator.eval(imp);
	implication = evaluator.apply("imp", Handle::UNDEFINED);

	// Create an implication link without the conjunction (AndLink)
	const char * imp2 =
	"(define (imp2)\n"
	"(ImplicationLink\n"
	"   (InheritanceLink (stv 1 1)\n"
	"      (VariableNode \"$predNode\")\n"
	"      (DefinedFrameNode \"#Manipulation\")\n"
	"   )\n"
	"   (VariableNode \"$predNode\")\n"
	")\n"
	")\n";
	evaluator.eval(imp2);
	implication2 = evaluator.apply("imp2", Handle::UNDEFINED);

	// Create an varscope link with just one variable
	const char * scope =
	"(define (varscope)\n"
	"(VariableScopeLink\n"
	"   (VariableNode \"$predNode\")\n"
	"   (ImplicationLink\n"
	"      (InheritanceLink (stv 1 1)\n"
	"         (VariableNode \"$predNode\")\n"
	"         (DefinedFrameNode \"#Manipulation\")\n"
	"      )\n"
	"      (VariableNode \"$predNode\")\n"
	"   )\n"
	")\n"
	")\n";
	evaluator.eval(scope);
	varscope = evaluator.apply("varscope", Handle::UNDEFINED);

	// Create data on which the above pattern should match
	const char * str = 
	"(InheritanceLink (stv 1.0 1.0) (cog-new-av 1 0 #f)\n"
	"   (DefinedFrameNode \"#Ingestion\")\n"
	"   (DefinedFrameNode \"#Manipulation\")\n"
	")\n"
	"(InheritanceLink (stv 1.0 1.0) (cog-new-av 1 0 #f)\n"
	"   (PredicateNode \"grab@a6460c2d-b5f8-4287-8882-028d12de42d2_Manipulation\")\n"
	"   (DefinedFrameNode \"#Manipulation\")\n"
	")\n";
	evaluator.eval(str);
#endif /* HAVE_GUILE */
}

/*
 * Basic implication link test.
 *
 * Expect to get the following result, given the above data:
 *
 *    ListLink
 *       DefinedFrameNode #Ingestion
 *       PredicateNode grab@a6460c2d-b5f8-4287-8882-028d12de42d2_Manipulation
 */
#define getlink(hand,pos) \
	dynamic_cast<Link *>(TLB::getAtom(hand))->getOutgoingHandle(pos)

#define getarity(hand) \
	dynamic_cast<Link *>(TLB::getAtom(hand))->getArity()

void ExecutionUTest::test_exec(void)
{
	logger().debug("BEGIN TEST: %s", __FUNCTION__);

	// Result should be a ListLink
	Handle result = pm.crisp_logic_imply(implication);
	logger().debug("result is %s\n", SchemeSmob::to_string(result).c_str());

	// There should be two solutions: 
	TSM_ASSERT_EQUALS("wrong number of solutions found", 2, getarity(result));

	// Result should be a ListLink w/ two solutions
	result = pm.crisp_logic_imply(implication2);
	logger().debug("result is %s\n", SchemeSmob::to_string(result).c_str());
	TSM_ASSERT_EQUALS("wrong number of solutions found", 2, getarity(result));

	// Result should be a ListLink w/ two solutions
	result = pm.varscope(varscope);
	logger().debug("result is %s\n", SchemeSmob::to_string(result).c_str());
	TSM_ASSERT_EQUALS("wrong number of solutions found", 2, getarity(result));

	logger().debug("END TEST: %s", __FUNCTION__);
}
