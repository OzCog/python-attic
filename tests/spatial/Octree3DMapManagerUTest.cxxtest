#include <cxxtest/TestSuite.h>

#include <cstdlib>
#include <string>

#include <opencog/atomspace/AtomSpace.h>
#include <opencog/atomspace/Handle.h>
#include <opencog/spacetime/atom_types.h>
#include <opencog/spatial/3DSpaceMap/OctomapOcTree.h>
#include <opencog/spatial/3DSpaceMap/Block3DMapUtil.h>

#include <opencog/util/Logger.h>

using namespace std;
using namespace opencog;
using namespace opencog::spatial;

bool entityIsSelf=true;
bool entityIsAvatar=true;
class Octree3DMapManagerUTest : public CxxTest::TestSuite
{ 

public:
    OctomapOcTree* testMap;
    AtomSpace as;

    void setUp()
    {
        string testMapName("testMap");
        unsigned resolution = 1;
        float agentheight = 1.6;
        testMap = new OctomapOcTree(testMapName, resolution, agentheight);
    }
    void tearDown()
    {
        delete testMap;
        testMap = NULL;
        as.clear();
    }

    void testGetBlock_NoBlockAdded_ReturnUndefinedHandle()
    {
        BlockVector testpos1(7,8,9);
        Handle testHandle = testMap->getBlock(testpos1);
        TS_ASSERT_EQUALS(Handle::UNDEFINED, testHandle);
    }
	
    void testBinaryAddandRemove_NormalUnitBlock_AllGetFunctionWork()
    {			
        BlockVector testpos1(7,8,9);
        Handle testHandle1(100);
        testMap->addSolidUnitBlock(testHandle1, testpos1);
        Handle testHandle2 = testMap->getBlock(testpos1);
        TS_ASSERT(testHandle2 == testHandle1);
        TS_ASSERT(testMap->getBlockLocation(testHandle1) == testpos1);

        testMap->removeSolidUnitBlock(testHandle1);

        Handle testHandle3 = testMap->getBlock(testpos1);
        TS_ASSERT(testHandle3 == Handle::UNDEFINED);
        TS_ASSERT(testMap->getBlockLocation(testHandle1) == BlockVector::ZERO);
    }

    void testAddSolidUnitBlock__PositionOverBorder__GetBlockFailed()
    {
        unsigned border = 32768;
        BlockVector testpos1(border, 8, 9);
        Handle testHandle1(100);
        testMap->addSolidUnitBlock(testHandle1, testpos1);
        Handle testHandle2 = testMap->getBlock(testpos1);
        TS_ASSERT_EQUALS(Handle::UNDEFINED, testHandle2);
    }

    void testSetBlock_AddBlockWithProbabilityControl_GetFunctionsWorkWithProb()
    {
        BlockVector testpos1(7,8,9);
        Handle testHandle1(100);
        float logOddThreshold = testMap->getOccupancyThresLog();

        testMap->setUnitBlock(testHandle1, testpos1, logOddThreshold);
		
        logger().error("threshold %f", logOddThreshold);
        logger().error("block occupancy %f", testMap->search(testpos1.x, testpos1.y, testpos1.z)->getLogOdds());

        //test binary getBlock
        TS_ASSERT(testMap->getBlock(testpos1) == testHandle1);
        // test prob getBlock
        TS_ASSERT(testMap->getBlock(testpos1, logOddThreshold) == testHandle1);
        TS_ASSERT(testMap->getBlockLocation(testHandle1) == testpos1);
        // test prob getblocklocation
        TS_ASSERT(testMap->getBlockLocation(testHandle1,logOddThreshold) == testpos1);

        //change the occupancy so it's small enough to make getter find nothing
        testMap->setUnitBlock(testHandle1, testpos1, -0.1);

        TS_ASSERT(testMap->getBlock(testpos1) == Handle::UNDEFINED);
        TS_ASSERT(testMap->getBlock(testpos1, logOddThreshold) == Handle::UNDEFINED);
        TS_ASSERT(testMap->getBlockLocation(testHandle1) == BlockVector::ZERO);
        TS_ASSERT(testMap->getBlockLocation(testHandle1, logOddThreshold) == BlockVector::ZERO);
		
        //change the threshold, so the occupancy is large enough to find it
        testMap->setOccupancyThres(-0.2);
        logOddThreshold = testMap->getOccupancyThresLog();

        TS_ASSERT(testMap->getBlock(testpos1) != Handle::UNDEFINED);
        TS_ASSERT(testMap->getBlock(testpos1,logOddThreshold) != Handle::UNDEFINED);
        TS_ASSERT(testMap->getBlockLocation(testHandle1) == testpos1);
        TS_ASSERT(testMap->getBlockLocation(testHandle1, logOddThreshold) == testpos1);
    }
	

    void testAddandRemoveNoneBlockEntity_NormalEntity_AllGetFunctionsWork()
    {
        BlockVector testpos1(17, 28, 39);
        unsigned long timestamp1 = 12345;
        Handle testHandle1 = as.add_node(ENTITY_NODE, "entity");
        testMap->addNoneBlockEntity(testHandle1, testpos1,
                                    !entityIsSelf, !entityIsAvatar, 
                                    timestamp1);

        Handle testHandle2 = testMap->getEntity(testpos1);
        TS_ASSERT(testHandle1 == testHandle2);
        TS_ASSERT(testMap->getLastAppearedLocation(testHandle1) == testpos1);
        testMap->removeNoneBlockEntity(testHandle1);
		
        TS_ASSERT(testMap->getEntity(testpos1) == Handle::UNDEFINED);
        //preserve record
        TS_ASSERT(testMap->getLastAppearedLocation(testHandle1) == testpos1);
    }

    void testUpdateEntityLocation_MultipleLocation_LastLocationIsPos2()
    {
        BlockVector testpos1(17, 28, 39);
        unsigned long timestamp1 = 12345;
        Handle testHandle1 = as.add_node(ENTITY_NODE, "entity");
        testMap->addNoneBlockEntity(testHandle1, testpos1,
                                    !entityIsSelf, !entityIsAvatar, 
                                    timestamp1);
        BlockVector testpos2(17, 28, 40);
        unsigned long timestamp2 = 12346;
        testMap->updateNoneBlockEntityLocation(testHandle1, testpos2, timestamp2);
        BlockVector lastLocation = testMap->getLastAppearedLocation(testHandle1);

        TS_ASSERT_EQUALS(testpos2, lastLocation);
    }

    void testAddEntity_PressureTest()
    {
        int count = 10000;
        while(count != 0)
        {
            char countstr[256];
            sprintf(countstr, "%d", count);
            count --;
            BlockVector testpos1(count, count, count);
            Handle testHandle1 = as.add_node(ENTITY_NODE, countstr);
            testMap->addNoneBlockEntity(testHandle1, testpos1,
                                        !entityIsSelf, !entityIsAvatar, 12345678892);
            Handle testHandle2 = testMap->getEntity(testpos1);
            TS_ASSERT(testHandle1 == testHandle2);
            TS_ASSERT(testMap->getLastAppearedLocation(testHandle1) == testpos1);
            testMap->removeNoneBlockEntity(testHandle1);
			
            TS_ASSERT(testMap->getEntity(testpos1) == Handle::UNDEFINED);
            //preserve record
            TS_ASSERT(testMap->getLastAppearedLocation(testHandle1) == testpos1);	
        }
    }

};
