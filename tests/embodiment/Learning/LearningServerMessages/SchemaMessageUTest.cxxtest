/**
 * SchemaMessageUTest
 *
 * Author: Carlos Lopes
 * Copyright(c), 2007
 */
#include <opencog/embodiment/Learning/LearningServerMessages/SchemaMessage.h>
#include <opencog/comboreduct/combo/type_tree.h>
#include <string.h>
#include <sstream>
#include <opencog/embodiment/PetComboVocabulary/PetComboVocabulary.h>

using namespace LearningServerMessages;
using namespace PetCombo;

static const std::string from  = "PET";
static const std::string to    = "LS";
static const std::string trick = "fetch";
static const std::string trickCandidate = "fetch_1";
static const std::string comboSchema = "and_seq(#1 #2 and_seq(#3 or_seq(#4 #5 or_seq(#6 #7 exec_seq(#8 #9 exec_seq(#10))))))";

class SchemaMessageUTest : public CxxTest::TestSuite
{

private:
    SchemaMessage * sm;
    combo::combo_tree schema;

    std::string toLoad;
    std::string loaded;

public:

    SchemaMessageUTest() {
        std::stringstream ss(comboSchema);
        ss >> schema;
    }

    ~SchemaMessageUTest() {
        delete(sm);
    }

    void testConstructor() {

        std::string invalidMsg = "trick_name***";
        SchemaMessage message(from, to);
        TS_ASSERT_THROWS(SchemaMessage(from, to, invalidMsg, MessagingSystem::Message::SCHEMA), opencog::InvalidParamException&);
    }

    void testGetPlainTextRepresentation() {
        sm = new SchemaMessage(from, to, schema, trick);
        TS_ASSERT(sm);

        toLoad = sm->getPlainTextRepresentation();

    }

    void testLoadPlainTextRepresentation() {
        SchemaMessage sm2(from, to);

        sm2.loadPlainTextRepresentation(toLoad.c_str());
        TS_ASSERT(sm2.getSchemaName() == sm->getSchemaName());
        TS_ASSERT(sm2.getSchema() == sm->getSchema());

        combo::combo_tree comboSchema2 = sm2.getComboSchema();

        combo::type_tree comboType = infer_type_tree(comboSchema2);
        bool ct = is_well_formed(comboType);

        TS_ASSERT(ct);
    }

    void setUp() {
    }

    void tearDown() {
    }

}; // class
