/**
 * FileMessageCentralUTest.cxxtest
 *
 * Author: 	Elvys
 * Date:	11/09/2007
 */

 
#include "FileMessageCentral.h"
#include "StringMessage.h"
#include "Message.h"
#include "util/numeric.h"
#include "stdio.h"
#include "stdlib.h"
#include "util/files.h"

#include <iostream>

using namespace MessagingSystem; 

class FileMessageCentralUTest :  public CxxTest::TestSuite{
public:

	FileMessageCentral *fmc;

	std::string id1, id2;

	Control::SystemParameters spar;

	FileMessageCentralUTest(){
            TS_ASSERT(fileExists(TEST_CONFIG_FILE));
	    spar.loadFromFile(TEST_CONFIG_FILE);
	}
	
	~FileMessageCentralUTest(){
    }
	
    void setUp(){


		fmc = new FileMessageCentral( spar );

		id1 = ("id1");
		id2 = ("id2");

    }
	
    void tearDown(){
    
    	delete fmc;
    	
    }

	void testCreateQueue(){
	
	
		
		fmc->createQueue(id2);
	
	    TS_ASSERT(fmc->existsQueue(id2));
	    
	}

	void testQueueOperations(){
		
		
		fmc->createQueue(id1);
		fmc->createQueue(id2);
	
	    TS_ASSERT(fmc->existsQueue(id1));
	
	    TS_ASSERT(fmc->isQueueEmpty(id1));
	    TS_ASSERT(fmc->isQueueEmpty(id2));
			
		StringMessage * str_message = new StringMessage(std::string("from"),std::string("to"), std::string("message 1")); 
		StringMessage * str_message2 = new StringMessage(std::string("from"),std::string("to"), std::string("message 2")); 
		Message *ret_message = NULL;
	
		ret_message = fmc->pop(id1);
		TS_ASSERT(ret_message == NULL);
	
		ret_message = fmc->pop(id2);
		TS_ASSERT(ret_message == NULL);
	
		fmc->push(id1, str_message);
	
		ret_message = fmc->pop(id2);
		TS_ASSERT(ret_message == NULL);
	
		fmc->push(id1, str_message2);
	
	    TS_ASSERT(!fmc->isQueueEmpty(id1));
		TS_ASSERT(fmc->isQueueEmpty(id2));
	
		ret_message = fmc->pop(id1);
		TS_ASSERT(ret_message != NULL);
		std::cout << ret_message->getPlainTextRepresentation() << "\n";	
	
		ret_message = fmc->pop(id1);
		TS_ASSERT(ret_message != NULL);
		std::cout << ret_message->getPlainTextRepresentation() << "\n";	
	
		ret_message = fmc->pop(id1);
		TS_ASSERT(ret_message == NULL);
	   
		
    }
  
	void testMultilinesMessages(){
			
		fmc->createQueue(id1);
	
		std::string mm("message line 1\nline 2\nline 3\n\n\n\n\n\n\n\n\n\nline 4");
		
		StringMessage * str_message = new StringMessage(std::string("from"),std::string("to"), mm); 

		Message *ret_message = NULL;
	
		fmc->push(id1, str_message);
	
		ret_message = fmc->pop(id1);
		
		TS_ASSERT(strlen(ret_message->getPlainTextRepresentation()) == strlen(mm.c_str()));

//		std::cout << ret_message->getPlainTextRepresentation();	
		
		delete ret_message;
	}		
	
    
    void testConcurrentQueueAccess(){
	
		pthread_t tid1, tid2, tid3;

		pthread_attr_t atid1, atid2, atid3;

		
		
		fmc->createQueue(id1);
    	TS_ASSERT(fmc->existsQueue(id1));

		fmc->createQueue(id2);
    	TS_ASSERT(fmc->existsQueue(id2));

		pthread_attr_init(&atid1);
		pthread_attr_init(&atid2);
		pthread_attr_init(&atid3);
        
        pthread_create(&tid1, &atid1, FileMessageCentralUTest::threadMessageQueueRandonAccess, (void*) fmc);
        pthread_create(&tid2, &atid2, FileMessageCentralUTest::threadMessageQueueRandonAccess, (void*) fmc);
        pthread_create(&tid3, &atid3, FileMessageCentralUTest::threadMessageQueueRandonAccess, (void*) fmc);

//		threadMessageQueueRandonAccess((void*) fmc);

// I need access the thread IDs structure, to make thread start. I dont know why, but It worked ...

		pthread_join(tid1, NULL);
		pthread_join(tid2, NULL);
		pthread_join(tid3, NULL);
		    
		while (!fmc->isQueueEmpty(id1)) {
			Message *ret_message = fmc->pop(id1);
				std::cout << "--pop---1-" << ret_message->getPlainTextRepresentation() << " END\n";
				delete ret_message;
		}

		while (!fmc->isQueueEmpty(id2)) {
			Message *ret_message = fmc->pop(id2);
				std::cout << "--pop---2-" << ret_message->getPlainTextRepresentation() << " END\n";
				delete ret_message;
		}

	}
    
   static void* threadMessageQueueRandonAccess(void* args) {

		std::cout << "Init \n";	

		std::string id1("id1");
		std::string id2("id2");
		
		FileMessageCentral *fmc = (FileMessageCentral *) args;

		for (int i = 0; i < 2000; i++) {

			int choice = opencog::randint(5);
			
			switch (choice) {
				case 0:
				case 1: {
					char num[40];
					std::string msg("message ");
					//itoa(i, num, 10);
					sprintf(num, "%d", i);
					msg.append(num);
					StringMessage * str_message = new StringMessage(std::string("from"),std::string("to"), msg); 
					
					if (opencog::randbool()) {
						fmc->push(id1, str_message);
						std::cout << "--push--1-" << msg << "\n";
					} else {
						fmc->push(id2, str_message);
						std::cout << "--push--2-" << msg << "\n";
					}
	            }
				break;
				case 2:
				case 3: {
					Message *ret_message = NULL;
	
					if (opencog::randbool()) {
						ret_message = fmc->pop(id1);
						if (ret_message != NULL) {
							std::cout << "--pop---1-" << ret_message->getPlainTextRepresentation() << " <<<<\n";
							
							delete ret_message;
						} else {
							std::cout << "--pop---1-" << i << " is null\n";
						}
					} else {
						ret_message = fmc->pop(id2);
						if (ret_message != NULL) {
							std::cout << "--pop---2-" << ret_message->getPlainTextRepresentation() << " <<<<\n";
							
							delete ret_message;
						} else {
							std::cout << "--pop---2-" << i << " is null\n";
						}
					}
				} 					
				break;
				case 4: {
	
					if (opencog::randbool()) {
						if (fmc->isQueueEmpty(id1)) {
							std::cout << "--ID1---IS EMPTY\n";
						} 
					} else {
						if (fmc->isQueueEmpty(id2)) {
							std::cout << "--ID2---IS EMPTY\n";
						}
					}
				}
				break;
			}     

		}//for
    
    	return NULL;
    }
    
};
