/** 
 * PAIUTest.cxxtest
 * 
 * Author: Welter Luigi 
 * Copyright(c), 2007
 */

#include "PAI.h"
#include "PetInterfaceMock.h"
#include "AtomSpaceUtil.h"
#include "ActionPlanSenderMock.h"
#include "PredefinedProcedureNames.h"

#include "util/exceptions.h"
#include "util/files.h"
#include "util/StringManipulator.h"

#include <opencog/atomspace/AtomSpace.h>
#include <atom_types_init.h>

#include "PAITestUtil.h"
#include "SystemParameters.h"

using namespace PerceptionActionInterface;
using namespace Control;

std::list<ActionPlan> sentActionPlans;

class PAIUTest :  public CxxTest::TestSuite {
    
private: 

public:
    PAIUTest(){
        opencog::atom_types_init::init();
    }

    ~PAIUTest(){
    }

    void setUp(){
    }

    void tearDown(){
        sentActionPlans.clear();
    }

    void testConstructor() {
        SystemParameters parameters;
        if(fileExists(parameters.get("CONFIG_FILE").c_str())){
    	    parameters.loadFromFile(parameters.get("CONFIG_FILE"));
        }

        AtomSpace atomSpace;
        
        OKActionPlanSender sender(sentActionPlans);
        PetInterfaceMock petInterface;
        PAI pai1(atomSpace, sender, petInterface, parameters);
        petInterface.setPAI(&pai1);
        ActionPlanID planId = pai1.createActionPlan();
        TS_ASSERT(planId == "0");
        PAI pai2(atomSpace, sender, petInterface, parameters, 10);
        petInterface.setPAI(&pai2);
        planId = pai2.createActionPlan();
        TS_ASSERT(planId == "10"); 
    }
    
#define NUM_PLANS 100    
    void testCreateActionPlan() {
        SystemParameters parameters;
        if(fileExists(parameters.get("CONFIG_FILE").c_str())){
    	    parameters.loadFromFile(parameters.get("CONFIG_FILE"));
        }
       
        AtomSpace atomSpace;
        
        OKActionPlanSender sender(sentActionPlans);
        PetInterfaceMock petInterface;
        PAI pai(atomSpace, sender, petInterface, parameters);
        petInterface.setPAI(&pai);
        ActionPlanID plans[NUM_PLANS];
        for (int i = 0; i < NUM_PLANS; i++) {
            plans[i] = pai.createActionPlan();
        } 
        for (int i = 0; i < NUM_PLANS; i++) {
            for (int j = 0; j < NUM_PLANS; j++) {
                if (i != j) {
                    TS_ASSERT(plans[i] != plans[j]);
                }
            } 
        } 
    }
    
    void testSendActionPlan() {
        SystemParameters parameters;
        if(fileExists(parameters.get("CONFIG_FILE").c_str())){
    	    parameters.loadFromFile(parameters.get("CONFIG_FILE"));
        }

        AtomSpace atomSpace;
        
        OKActionPlanSender sender(sentActionPlans);
        PetInterfaceMock petInterface;
        PAI pai(atomSpace, sender, petInterface, parameters);
        petInterface.setPAI(&pai);

        TS_ASSERT_THROWS(pai.sendActionPlan("0"), opencog::RuntimeException&);
        TS_ASSERT_THROWS(pai.sendActionPlan("1"), opencog::RuntimeException&);
        TS_ASSERT_THROWS(pai.sendActionPlan("10"), opencog::RuntimeException&);

        ActionPlanID plans[NUM_PLANS];
        for (int i = 0; i < NUM_PLANS; i++) {
            plans[i] = pai.createActionPlan();
        } 
        for (unsigned int i = 0; i < NUM_PLANS; i++) {
            pai.sendActionPlan(plans[i]);
            // check if it called the sendActionPlan method of the ActionPlanSender
            TS_ASSERT(sentActionPlans.size() == i+1);
        }
        
        FailureActionPlanSender sender2;
        PAI pai2(atomSpace, sender2, petInterface, parameters);

        TS_ASSERT_THROWS(pai2.sendActionPlan("0"), opencog::RuntimeException&);
        TS_ASSERT_THROWS(pai2.sendActionPlan("1"), opencog::RuntimeException&);
        TS_ASSERT_THROWS(pai2.sendActionPlan("10"), opencog::RuntimeException&);
        for (int i = 0; i < NUM_PLANS; i++) {
            plans[i] = pai2.createActionPlan();
        } 
        for (int i = 0; i < NUM_PLANS; i++) {
            TS_ASSERT_THROWS(pai2.sendActionPlan(plans[i]), opencog::RuntimeException&);
        }
    }
    
    void testAddAction() {
        printf("testAddAction\n");
        SystemParameters parameters;
        if(fileExists(parameters.get("CONFIG_FILE").c_str())){
    	    parameters.loadFromFile(parameters.get("CONFIG_FILE"));
        }
 

        AtomSpace atomSpace;
        
        OKActionPlanSender sender(sentActionPlans);
        PetInterfaceMock petInterface;
        PAI pai(atomSpace, sender, petInterface, parameters);
        petInterface.setPAI(&pai);
        ActionPlanID plan1 = pai.createActionPlan();
        ActionPlanID plan2 = pai.createActionPlan();
        pai.addAction(plan1, PetAction(ActionType::TRICK_FOR_FOOD()));
        TS_ASSERT_THROWS(pai.addAction(plan1, PetAction(ActionType::WALK())), opencog::InvalidParamException&); // invalid parameters
        pai.sendActionPlan(plan1);
        TS_ASSERT(sentActionPlans.size() == 1);
        TS_ASSERT(sentActionPlans.front().getAction(1).getType() == ActionType::TRICK_FOR_FOOD());
        PetAction walkAction(ActionType::WALK());
        walkAction.addParameter(ActionParameter("target", ActionParamType::VECTOR(), Vector(1.2, 1.3, 1.4)));
        walkAction.addParameter(ActionParameter("speed",ActionParamType::FLOAT(), "10.5"));
        walkAction.addParameter(ActionParameter("rotate", ActionParamType::ROTATION(), Rotation(1.2, 1.3, 1.4)));
        pai.addAction(plan2, walkAction);
        pai.addAction(plan2, PetAction(ActionType::BARK()));
        PetAction eatAction(ActionType::EAT());
        eatAction.addParameter(ActionParameter("object", ActionParamType::ENTITY(), Entity(PAIUtils::getInternalId("10"), "pet")));
        pai.addAction(plan2, eatAction);
        PetAction flyAction(ActionType::FLY());
        flyAction.addParameter(ActionParameter("target", ActionParamType::VECTOR(), Vector(1.2, 1.3, 1.4)));
        flyAction.addParameter(ActionParameter("speed",ActionParamType::FLOAT(), "10.5"));
        pai.addAction(plan2, flyAction);
        TS_ASSERT_THROWS(pai.addAction(plan2, PetAction(ActionType::JUMP_TOWARD())), opencog::InvalidParamException&); // invalid parameters
        pai.sendActionPlan(plan2);
        TS_ASSERT(sentActionPlans.size() == 2);
        TS_ASSERT(sentActionPlans.back().getAction(1).getType() == ActionType::WALK());
        TS_ASSERT(sentActionPlans.back().getAction(2).getType() == ActionType::BARK());
        TS_ASSERT(sentActionPlans.back().getAction(3).getType() == ActionType::EAT());
        TS_ASSERT(sentActionPlans.back().getAction(4).getType() == ActionType::FLY());
        
        
        
    }
    
    void testProcessPVPMessage() {
        printf("testProcessPVPMessage\n");
        HandleSeq toUpdateHandles;
         SystemParameters parameters;
        if(fileExists(parameters.get("CONFIG_FILE").c_str())){
    	    parameters.loadFromFile(parameters.get("CONFIG_FILE"));
        }
       
        AtomSpace atomSpace;
        
        OKActionPlanSender sender(sentActionPlans);
        PetInterfaceMock petInterface;
        PAI pai(atomSpace, sender, petInterface, parameters, 10);
        petInterface.setPAI(&pai);
        
        // Check Action Plan status before creating them, according with the passed "nextActionPlanId" argument to the constructor
        TS_ASSERT(!pai.hasPlanFailed("0"));
        TS_ASSERT(!pai.hasPlanFailed("9"));
        TS_ASSERT(!pai.hasPlanFailed("10"));
        TS_ASSERT(pai.isPlanFinished("0"));
        TS_ASSERT(pai.isPlanFinished("9"));
        TS_ASSERT(!pai.isPlanFinished("10"));

        // Send an action-plan to get/process the corresponding pet-signal later
        ActionPlanID planId = pai.createActionPlan();
        TS_ASSERT(planId == "10");
        
        PetAction action1(ActionType::BARK());
        action1.addParameter(ActionParameter("target", ActionParamType::ENTITY(), Entity(PAIUtils::getInternalId("Wynx"), "avatar"))); 
        action1.addParameter(ActionParameter("duration", ActionParamType::FLOAT(), "1.0")); 
        ActionID actionId1 = pai.addAction(planId, action1);
        
        PetAction action2(ActionType::WALK());
        action2.addParameter(ActionParameter("target", ActionParamType::VECTOR(), Vector(10.0,15.0,20.0))); 
        action2.addParameter(ActionParameter("speed", ActionParamType::FLOAT(), opencog::toString(1.0))); 
        action2.addParameter(ActionParameter("frameOfReference", ActionParamType::ROTATION(), Rotation(0.5,0.0,-3.0))); 
        ActionID actionId2 = pai.addAction(planId, action2);

        pai.sendActionPlan(planId);
        
        planId = pai.createActionPlan();
        TS_ASSERT(planId == "11");
        
        PetAction action3(ActionType::BARK());
        ActionID actionId3 = pai.addAction(planId, action3);
        
        pai.sendActionPlan(planId);
        
        planId = pai.createActionPlan();
        TS_ASSERT(planId == "12");
        
        PetAction action4(ActionType::GRAB());
        action4.addParameter(ActionParameter("target", ActionParamType::ENTITY(), Entity(PAIUtils::getInternalId("Wynx"), "avatar"))); 
        ActionID actionId4 = pai.addAction(planId, action4);
        
        pai.sendActionPlan(planId);
        
        planId = pai.createActionPlan();
        TS_ASSERT(planId == "13");
        
        PetAction action5(ActionType::DROP());
        ActionID actionId5 = pai.addAction(planId, action5);
        
        pai.sendActionPlan(planId);
     
        // GETS THE TIME THE ACTIONS WERE SENT FOR FURTHER USE: 
        unsigned long justBeforeActionStatusTimestamp = PAI::getTimestampFromXsdDateTimeStr( ( boost::posix_time::to_iso_extended_string( PAIUtils::getSystemEpoch( ) ) + ".900" ).c_str( ) );
        cout << "justBeforeActionStatusTimestamp = " << justBeforeActionStatusTimestamp << endl;

        // Check Action Plan status before receiveing any message from PVP
        TS_ASSERT(!pai.hasPlanFailed("0"));
        TS_ASSERT(!pai.hasPlanFailed("9"));
        TS_ASSERT(!pai.hasPlanFailed("10"));
        TS_ASSERT(!pai.hasPlanFailed("11"));
        TS_ASSERT(!pai.hasPlanFailed("12"));
        TS_ASSERT(!pai.hasPlanFailed("13"));
        TS_ASSERT(pai.isPlanFinished("0"));
        TS_ASSERT(pai.isPlanFinished("9"));
        TS_ASSERT(!pai.isPlanFinished("10"));
        TS_ASSERT(!pai.isPlanFinished("11"));
        TS_ASSERT(!pai.isPlanFinished("12"));
        TS_ASSERT(!pai.isPlanFinished("13"));

        TS_ASSERT(pai.getLatestSimWorldTimestamp() == 0);

        // process first message
        string pvpMsg1;
        TS_ASSERT(appendFileContent(PVP_XML_FILE_PATH "/pvpMsg1.xml", pvpMsg1));
        cout << "processing first pvp message (" << PVP_XML_FILE_PATH << "/pvpMsg1.xml" << ")" << endl << pvpMsg1 << endl;
        TS_ASSERT(pai.processPVPMessage(pvpMsg1, toUpdateHandles));

        // Check latest received/processed timestamp
        TS_ASSERT(pai.getLatestSimWorldTimestamp() == PAI::getTimestampFromXsdDateTimeStr("2007-06-18T20:15:01.000-07:00"));

        // Check instruction atoms in AtomSpace
        {
            cout << "checking instructions" << endl;
            Handle predNode = atomSpace.getHandle(PREDICATE_NODE, ACTION_DONE_PREDICATE_NAME);
            TS_ASSERT(CoreUtils::compare(predNode, Handle::UNDEFINED));
            Handle saySchemaNode = atomSpace.getHandle(GROUNDED_SCHEMA_NODE, SAY_SCHEMA_NAME);
            TS_ASSERT(CoreUtils::compare(saySchemaNode, Handle::UNDEFINED));
            Handle avatarNode = atomSpace.getHandle(SL_AVATAR_NODE, PAIUtils::getInternalId("2"));
            TS_ASSERT(CoreUtils::compare(avatarNode, Handle::UNDEFINED));
            
            const char* sentences[6] = { "Learn to fetch", "I fetch", "done fetch", 
                                         "stop learning to fetch", "Good boy!!", "Bad boy!!" };
            for (int i = 0; i < 6; i++) {
                string sentenceName("to:"); 
                sentenceName += PAIUtils::getInternalId("1");
                sentenceName += (": ");
                sentenceName += sentences[i];
                Handle sentenceNode = atomSpace.getHandle(SENTENCE_NODE, sentenceName);
                cout << sentences[i] << endl;
                TS_ASSERT(CoreUtils::compare(sentenceNode, Handle::UNDEFINED));
            
                HandleSeq schemaListLinkOutgoing;
                schemaListLinkOutgoing.push_back(avatarNode);
                schemaListLinkOutgoing.push_back(sentenceNode);
                Handle schemaListLink = atomSpace.getHandle(LIST_LINK, schemaListLinkOutgoing);
                TS_ASSERT(CoreUtils::compare(schemaListLink, Handle::UNDEFINED));
    
                HandleSeq execLinkOutgoing;
                execLinkOutgoing.push_back(saySchemaNode);
                execLinkOutgoing.push_back(schemaListLink);
                Handle execLink = atomSpace.getHandle(EXECUTION_LINK, execLinkOutgoing);
                TS_ASSERT(CoreUtils::compare(execLink, Handle::UNDEFINED));
    
                HandleSeq predicateListLinkOutgoing;
                predicateListLinkOutgoing.push_back(execLink);
                Handle predicateListLink = atomSpace.getHandle(LIST_LINK, predicateListLinkOutgoing);
                TS_ASSERT(CoreUtils::compare(predicateListLink, Handle::UNDEFINED));
    

                HandleSeq evalLinkOutgoing;
                evalLinkOutgoing.push_back(predNode);
                evalLinkOutgoing.push_back(predicateListLink);
		Handle evalLink = atomSpace.getHandle(EVALUATION_LINK, evalLinkOutgoing);
                TS_ASSERT(CoreUtils::compare(evalLink, Handle::UNDEFINED));
            }
        }

        // Check Pet-signal atoms

        // Check Physiological feeling in AtomSpace
        {
            cout << "checking pet signals: physiological feelings " << endl;
            string str = PAIUtils::getInternalId("1");
            str += ".hunger";
            Handle predNode = atomSpace.getHandle(PREDICATE_NODE, str.c_str());
            TS_ASSERT(CoreUtils::compare(predNode, Handle::UNDEFINED));
            Handle paramNameNode = atomSpace.getHandle(NODE, "level");
            TS_ASSERT(CoreUtils::compare(paramNameNode, Handle::UNDEFINED));
            Handle paramValueNode = atomSpace.getHandle(NODE, "0.90");
            TS_ASSERT(CoreUtils::compare(paramValueNode, Handle::UNDEFINED));
            HandleSeq innerListLinkOutgoing;
            innerListLinkOutgoing.push_back(paramNameNode);
            innerListLinkOutgoing.push_back(paramValueNode);
            Handle innerListLink = atomSpace.getHandle(LIST_LINK, innerListLinkOutgoing);
            TS_ASSERT(CoreUtils::compare(innerListLink, Handle::UNDEFINED));
            HandleSeq outterListLinkOutgoing;
            outterListLinkOutgoing.push_back(innerListLink);
            Handle outterListLink = atomSpace.getHandle(LIST_LINK, outterListLinkOutgoing);
            TS_ASSERT(CoreUtils::compare(outterListLink, Handle::UNDEFINED));
            HandleSeq evalLinkOutgoing;
            evalLinkOutgoing.push_back(predNode);
            evalLinkOutgoing.push_back(outterListLink);
            Handle evalLink = atomSpace.getHandle(EVALUATION_LINK, evalLinkOutgoing);
            TS_ASSERT(CoreUtils::compare(evalLink, Handle::UNDEFINED));
        }

        // Check Action Plan status
        TS_ASSERT(!pai.hasPlanFailed("0"));
        TS_ASSERT(!pai.hasPlanFailed("9"));
        TS_ASSERT(pai.hasPlanFailed("10"));
        TS_ASSERT(!pai.hasPlanFailed("11"));
        TS_ASSERT(!pai.hasPlanFailed("12"));
        TS_ASSERT(!pai.hasPlanFailed("13"));
        TS_ASSERT(pai.isPlanFinished("0"));
        TS_ASSERT(pai.isPlanFinished("9"));
        TS_ASSERT(!pai.isPlanFinished("10"));
        TS_ASSERT(!pai.isPlanFinished("11"));
        TS_ASSERT(!pai.isPlanFinished("12"));
        TS_ASSERT(!pai.isPlanFinished("13"));

        // Check Action status in AtomSpace
        {
            // FIRST, USING PAI SPECIAL METHODS: 
            TS_ASSERT(!pai.isActionDone(actionId1, justBeforeActionStatusTimestamp)); 
            TS_ASSERT(!pai.isActionDone(actionId2, justBeforeActionStatusTimestamp)); 
            TS_ASSERT(!pai.isActionDone(actionId3, justBeforeActionStatusTimestamp)); 
            TS_ASSERT(!pai.isActionDone(actionId4, justBeforeActionStatusTimestamp)); 
            TS_ASSERT(!pai.isActionDone(actionId5, justBeforeActionStatusTimestamp)); 
            TS_ASSERT(!pai.isActionFailed(actionId1, justBeforeActionStatusTimestamp)); 
            TS_ASSERT(pai.isActionFailed(actionId2, justBeforeActionStatusTimestamp)); 
            TS_ASSERT(!pai.isActionFailed(actionId3, justBeforeActionStatusTimestamp)); 
            TS_ASSERT(!pai.isActionFailed(actionId4, justBeforeActionStatusTimestamp)); 
            TS_ASSERT(!pai.isActionFailed(actionId5, justBeforeActionStatusTimestamp)); 
            
            // THEN, USING THE HARD WAY 
            
            cout << "checking pet signals: action status " << endl;
            Handle predNode = atomSpace.getHandle(PREDICATE_NODE, ACTION_FAILED_PREDICATE_NAME);
            TS_ASSERT(CoreUtils::compare(predNode, Handle::UNDEFINED));
            Handle schemaNode = atomSpace.getHandle(GROUNDED_SCHEMA_NODE, ActionType::WALK().getName());
            TS_ASSERT(CoreUtils::compare(schemaNode, Handle::UNDEFINED));

            /*
            HandleSeq numberNodes;
            atomSpace.getHandleSet(back_inserter(numberNodes), NUMBER_NODE, false);
            cout << "Got " << numberNodes.size() << " NumberNodes:" << endl;
            for (int i = 0; i < numberNodes.size(); i++) {
                cout << TLB::getAtom(numberNodes[i])->toString() << endl;
            } 
            */

            // Action parameters
            HandleSeq schemaListLinkOutgoing;

            // Vector target: action2.addParameter(ActionParameter("target", ActionParamType::VECTOR(), Vector(10.0,15.0,20.0)));
            Handle xNode = atomSpace.getHandle(NUMBER_NODE, "10");
            TS_ASSERT(CoreUtils::compare(xNode, Handle::UNDEFINED));
            Handle yNode = atomSpace.getHandle(NUMBER_NODE, "15");
            TS_ASSERT(CoreUtils::compare(yNode, Handle::UNDEFINED));
            Handle zNode = atomSpace.getHandle(NUMBER_NODE, "20");
            TS_ASSERT(CoreUtils::compare(zNode, Handle::UNDEFINED));
            HandleSeq targetListLinkOutgoing;
            targetListLinkOutgoing.push_back(xNode); 
            targetListLinkOutgoing.push_back(yNode); 
            targetListLinkOutgoing.push_back(zNode); 
            Handle targetListLink = atomSpace.getHandle(LIST_LINK, targetListLinkOutgoing);
            schemaListLinkOutgoing.push_back(targetListLink);
            
            // Float speed: action2.addParameter(ActionParameter("speed", ActionParamType::FLOAT(), toString(1.0)));
            Handle speedNode = atomSpace.getHandle(NUMBER_NODE, "1");
            TS_ASSERT(CoreUtils::compare(speedNode, Handle::UNDEFINED));
            schemaListLinkOutgoing.push_back(speedNode);
             
            // Rotation rotate: action2.addParameter(ActionParameter("rotate", ActionParamType::ROTATION(), Rotation(0.5,0.0,-3.0)));
            Handle pitchNode = atomSpace.getHandle(NUMBER_NODE, "0.5");
            TS_ASSERT(CoreUtils::compare(pitchNode, Handle::UNDEFINED));
            Handle rollNode = atomSpace.getHandle(NUMBER_NODE, "0");
            TS_ASSERT(CoreUtils::compare(rollNode, Handle::UNDEFINED));
            Handle yawNode = atomSpace.getHandle(NUMBER_NODE, "-3");
            TS_ASSERT(CoreUtils::compare(yawNode, Handle::UNDEFINED));
            HandleSeq rotateListLinkOutgoing;
            rotateListLinkOutgoing.push_back(pitchNode); 
            rotateListLinkOutgoing.push_back(rollNode); 
            rotateListLinkOutgoing.push_back(yawNode); 
            Handle rotateListLink = atomSpace.getHandle(LIST_LINK, rotateListLinkOutgoing);
            schemaListLinkOutgoing.push_back(rotateListLink);
            
            Handle schemaListLink = atomSpace.getHandle(LIST_LINK, schemaListLinkOutgoing);
            TS_ASSERT(CoreUtils::compare(schemaListLink, Handle::UNDEFINED));

            HandleSeq execLinkOutgoing;
            execLinkOutgoing.push_back(schemaNode);
            execLinkOutgoing.push_back(schemaListLink);
            Handle execLink = atomSpace.getHandle(EXECUTION_LINK, execLinkOutgoing);
            TS_ASSERT(CoreUtils::compare(execLink, Handle::UNDEFINED));

            HandleSeq predicateListLinkOutgoing;
            predicateListLinkOutgoing.push_back(execLink);
            Handle predicateListLink = atomSpace.getHandle(LIST_LINK, predicateListLinkOutgoing);
            TS_ASSERT(CoreUtils::compare(predicateListLink, Handle::UNDEFINED));

            HandleSeq evalLinkOutgoing;
            evalLinkOutgoing.push_back(predNode);
            evalLinkOutgoing.push_back(predicateListLink);
            Handle evalLink = atomSpace.getHandle(EVALUATION_LINK, evalLinkOutgoing);
            TS_ASSERT(CoreUtils::compare(evalLink, Handle::UNDEFINED));
        }

        // process next message        
        string pvpMsg2;
        TS_ASSERT(appendFileContent(PVP_XML_FILE_PATH "/pvpMsg2.xml", pvpMsg2));
        cout << "processing second pvp message (" << PVP_XML_FILE_PATH << "/pvpMsg2.xml" << ")" << endl << pvpMsg2 << endl;
        TS_ASSERT(pai.processPVPMessage(pvpMsg2, toUpdateHandles));

        // Check latest received/processed timestamp
        TS_ASSERT(pai.getLatestSimWorldTimestamp() == PAI::getTimestampFromXsdDateTimeStr("2007-06-18T20:15:03.000-07:00"));

        // Check Action Plan status
        TS_ASSERT(!pai.hasPlanFailed("0"));
        TS_ASSERT(!pai.hasPlanFailed("9"));
        TS_ASSERT(pai.hasPlanFailed("10"));
        TS_ASSERT(!pai.hasPlanFailed("11"));
        TS_ASSERT(!pai.hasPlanFailed("12"));
        TS_ASSERT(!pai.hasPlanFailed("13"));
        TS_ASSERT(pai.isPlanFinished("0"));
        TS_ASSERT(pai.isPlanFinished("9"));
        TS_ASSERT(pai.isPlanFinished("10"));
        TS_ASSERT(pai.isPlanFinished("11"));
        TS_ASSERT(pai.isPlanFinished("12"));
        TS_ASSERT(!pai.isPlanFinished("13"));

        // Check Action status in AtomSpace

        // CHECK ACTION STATUS USING PAI SPECIAL METHODS: 
        TS_ASSERT(pai.isActionDone(actionId1, justBeforeActionStatusTimestamp)); 
        TS_ASSERT(!pai.isActionDone(actionId2, justBeforeActionStatusTimestamp)); 
        TS_ASSERT(pai.isActionDone(actionId3, justBeforeActionStatusTimestamp)); 
        TS_ASSERT(!pai.isActionFailed(actionId1, justBeforeActionStatusTimestamp)); 
        TS_ASSERT(pai.isActionFailed(actionId2, justBeforeActionStatusTimestamp)); 
        TS_ASSERT(!pai.isActionFailed(actionId3, justBeforeActionStatusTimestamp)); 
            
        // Get the status for the first action
        {
            cout << "checking pet signals: action status" << endl;
            Handle predNode = atomSpace.getHandle(PREDICATE_NODE, ACTION_DONE_PREDICATE_NAME);
            TS_ASSERT(CoreUtils::compare(predNode, Handle::UNDEFINED));
            Handle schemaNode = atomSpace.getHandle(GROUNDED_SCHEMA_NODE, ActionType::BARK().getName());
            TS_ASSERT(CoreUtils::compare(schemaNode, Handle::UNDEFINED));

            HandleSeq schemaListLinkOutgoing;
            
            //Action parameters:
            //action1.addParameter(ActionParameter("duration", ActionParamType::FLOAT(), "1.0")); 
            //action1.addParameter(ActionParameter("target", ActionParamType::ENTITY(), Entity(PAIUtils::getInternalId("Wynx"), "avatar"))); 
            Handle avatarNode = atomSpace.getHandle(SL_AVATAR_NODE, PAIUtils::getInternalId("Wynx").c_str());
            TS_ASSERT(CoreUtils::compare(avatarNode, Handle::UNDEFINED));
            schemaListLinkOutgoing.push_back(avatarNode);
            Handle numberNode = atomSpace.getHandle(NUMBER_NODE, "1.0");
            TS_ASSERT(CoreUtils::compare(numberNode, Handle::UNDEFINED));
            schemaListLinkOutgoing.push_back(numberNode);
            
            Handle schemaListLink = atomSpace.getHandle(LIST_LINK, schemaListLinkOutgoing);
            TS_ASSERT(CoreUtils::compare(schemaListLink, Handle::UNDEFINED));

            HandleSeq execLinkOutgoing;
            execLinkOutgoing.push_back(schemaNode);
            execLinkOutgoing.push_back(schemaListLink);
            Handle execLink = atomSpace.getHandle(EXECUTION_LINK, execLinkOutgoing);
            TS_ASSERT(CoreUtils::compare(execLink, Handle::UNDEFINED));

            HandleSeq predicateListLinkOutgoing;
            predicateListLinkOutgoing.push_back(execLink);
            Handle predicateListLink = atomSpace.getHandle(LIST_LINK, predicateListLinkOutgoing);
            TS_ASSERT(CoreUtils::compare(predicateListLink, Handle::UNDEFINED));

            HandleSeq evalLinkOutgoing;
            evalLinkOutgoing.push_back(predNode);
            evalLinkOutgoing.push_back(predicateListLink);
            Handle evalLink = atomSpace.getHandle(EVALUATION_LINK, evalLinkOutgoing);
            TS_ASSERT(CoreUtils::compare(evalLink, Handle::UNDEFINED));
        }

        // Get the status for the third action
        {
            cout << "checking pet signals: action status" << endl;
            Handle predNode = atomSpace.getHandle(PREDICATE_NODE, ACTION_DONE_PREDICATE_NAME);
            TS_ASSERT(CoreUtils::compare(predNode, Handle::UNDEFINED));
            Handle schemaNode = atomSpace.getHandle(GROUNDED_SCHEMA_NODE, ActionType::BARK().getName());
            TS_ASSERT(CoreUtils::compare(schemaNode, Handle::UNDEFINED));

            HandleSeq schemaListLinkOutgoing;
            Handle schemaListLink = atomSpace.getHandle(LIST_LINK, schemaListLinkOutgoing);
            TS_ASSERT(CoreUtils::compare(schemaListLink, Handle::UNDEFINED));

            HandleSeq execLinkOutgoing;
            execLinkOutgoing.push_back(schemaNode);
            execLinkOutgoing.push_back(schemaListLink);
            Handle execLink = atomSpace.getHandle(EXECUTION_LINK, execLinkOutgoing);
            TS_ASSERT(CoreUtils::compare(execLink, Handle::UNDEFINED));

            HandleSeq predicateListLinkOutgoing;
            predicateListLinkOutgoing.push_back(execLink);
            Handle predicateListLink = atomSpace.getHandle(LIST_LINK, predicateListLinkOutgoing);
            TS_ASSERT(CoreUtils::compare(predicateListLink, Handle::UNDEFINED));

            HandleSeq evalLinkOutgoing;
            evalLinkOutgoing.push_back(predNode);
            evalLinkOutgoing.push_back(predicateListLink);
            Handle evalLink = atomSpace.getHandle(EVALUATION_LINK, evalLinkOutgoing);
            TS_ASSERT(CoreUtils::compare(evalLink, Handle::UNDEFINED));
        }

        // Check grab status in PetInterface
        {
            TS_ASSERT(!pai.hasPlanFailed("12"));
            TS_ASSERT(!pai.hasPlanFailed("13"));
            TS_ASSERT(pai.isPlanFinished("12"));
            TS_ASSERT(!pai.isPlanFinished("13"));
            
            TS_ASSERT(pai.getPetInterface().hasGrabbedObj());
            TS_ASSERT(pai.getPetInterface().getGrabbedObj() == PAIUtils::getInternalId("Wynx"));
        }

        // Check Avatar-signal atoms
        {
            cout << "checking avatar signals" << endl;
            
            Handle predNode = atomSpace.getHandle(PREDICATE_NODE, ACTION_DONE_PREDICATE_NAME);
            TS_ASSERT(CoreUtils::compare(predNode, Handle::UNDEFINED));

            HandleSeq predicateListLinkOutgoing;
            
            // Avatar node 
            Handle avatarNode = atomSpace.getHandle(SL_AVATAR_NODE, PAIUtils::getInternalId("1").c_str());
            TS_ASSERT(CoreUtils::compare(avatarNode, Handle::UNDEFINED));
            predicateListLinkOutgoing.push_back(avatarNode);
            
            // Action node
            Handle actionNode = atomSpace.getHandle(NODE, "walk");
            TS_ASSERT(CoreUtils::compare(actionNode, Handle::UNDEFINED));
            predicateListLinkOutgoing.push_back(actionNode);

            /* print NumberNodes
            HandleSeq numberNodes;
            atomSpace.getHandleSet(back_inserter(numberNodes), NUMBER_NODE, false);
            cout << "Got " << numberNodes.size() << " NumberNodes:" << endl;
            for (int i = 0; i < numberNodes.size(); i++) {
                cout << TLB::getAtom(numberNodes[i])->toString() << endl;
            } 
            */

            // Vector <vector x=\"1\" y=\"1.5\" z=\"2\"/>"
            Handle xNode = atomSpace.getHandle(NUMBER_NODE, "1");
            TS_ASSERT(CoreUtils::compare(xNode, Handle::UNDEFINED));
            Handle yNode = atomSpace.getHandle(NUMBER_NODE, "1.5");
            TS_ASSERT(CoreUtils::compare(yNode, Handle::UNDEFINED));
            Handle zNode = atomSpace.getHandle(NUMBER_NODE, "2");
            TS_ASSERT(CoreUtils::compare(zNode, Handle::UNDEFINED));
            HandleSeq targetListLinkOutgoing;
            targetListLinkOutgoing.push_back(xNode); 
            targetListLinkOutgoing.push_back(yNode); 
            targetListLinkOutgoing.push_back(zNode); 
            Handle targetListLink = atomSpace.getHandle(LIST_LINK, targetListLinkOutgoing);
            predicateListLinkOutgoing.push_back(targetListLink);
            
            // Speed <param name=\"speed\" type=\"float\" value=\"3.5\"/>"
            Handle speedNode = atomSpace.getHandle(NUMBER_NODE, "3.5");
            TS_ASSERT(CoreUtils::compare(speedNode, Handle::UNDEFINED));
            predicateListLinkOutgoing.push_back(speedNode);
             
            // Rotation <rotation pitch=\"0.1\" roll=\"0.2\" yaw=\"0.3\"/>"
            Handle pitchNode = atomSpace.getHandle(NUMBER_NODE, "0.1");
            TS_ASSERT(CoreUtils::compare(pitchNode, Handle::UNDEFINED));
            Handle rollNode = atomSpace.getHandle(NUMBER_NODE, "0.2");
            TS_ASSERT(CoreUtils::compare(rollNode, Handle::UNDEFINED));
            Handle yawNode = atomSpace.getHandle(NUMBER_NODE, "0.3");
            TS_ASSERT(CoreUtils::compare(yawNode, Handle::UNDEFINED));
            HandleSeq rotateListLinkOutgoing;
            rotateListLinkOutgoing.push_back(pitchNode); 
            rotateListLinkOutgoing.push_back(rollNode); 
            rotateListLinkOutgoing.push_back(yawNode); 
            Handle rotateListLink = atomSpace.getHandle(LIST_LINK, rotateListLinkOutgoing);
            predicateListLinkOutgoing.push_back(rotateListLink);
            
            Handle predicateListLink = atomSpace.getHandle(LIST_LINK, predicateListLinkOutgoing);
            TS_ASSERT(CoreUtils::compare(predicateListLink, Handle::UNDEFINED));

            HandleSeq evalLinkOutgoing;
            evalLinkOutgoing.push_back(predNode);
            evalLinkOutgoing.push_back(predicateListLink);
            Handle evalLink = atomSpace.getHandle(EVALUATION_LINK, evalLinkOutgoing);
            TS_ASSERT(CoreUtils::compare(evalLink, Handle::UNDEFINED));
        }



        // Check Agent-signal atoms (pet)
        {
            cout << "checking agent signals" << endl;
            
            Handle predNode = atomSpace.getHandle(PREDICATE_NODE, ACTION_DONE_PREDICATE_NAME);
            TS_ASSERT(CoreUtils::compare(predNode, Handle::UNDEFINED));

            HandleSeq predicateListLinkOutgoing;
            
            // Agent node 
            Handle agentNode = atomSpace.getHandle(SL_PET_NODE, PAIUtils::getInternalId("3").c_str());
            TS_ASSERT(CoreUtils::compare(agentNode, Handle::UNDEFINED));
            predicateListLinkOutgoing.push_back(agentNode);
            
            // Action node
            Handle actionNode = atomSpace.getHandle(NODE, "walk");
            TS_ASSERT(CoreUtils::compare(actionNode, Handle::UNDEFINED));
            predicateListLinkOutgoing.push_back(actionNode);

	    HandleSeq parametersListLink;

            // Vector <vector x=\"3\" y=\"5.5\" z=\"2.9\"/>"
            Handle xNode = atomSpace.getHandle(NUMBER_NODE, "3");
            TS_ASSERT(CoreUtils::compare(xNode, Handle::UNDEFINED));
            Handle yNode = atomSpace.getHandle(NUMBER_NODE, "5.5");
            TS_ASSERT(CoreUtils::compare(yNode, Handle::UNDEFINED));
            Handle zNode = atomSpace.getHandle(NUMBER_NODE, "2.9");
            TS_ASSERT(CoreUtils::compare(zNode, Handle::UNDEFINED));
            HandleSeq targetListLinkOutgoing;
            targetListLinkOutgoing.push_back(xNode); 
            targetListLinkOutgoing.push_back(yNode); 
            targetListLinkOutgoing.push_back(zNode); 
            Handle targetListLink = atomSpace.getHandle(LIST_LINK, targetListLinkOutgoing);
            parametersListLink.push_back(targetListLink);
            
            // Speed <param name=\"speed\" type=\"float\" value=\"3.87\"/>"
            Handle speedNode = atomSpace.getHandle(NUMBER_NODE, "3.87");
            TS_ASSERT(CoreUtils::compare(speedNode, Handle::UNDEFINED));
            parametersListLink.push_back(speedNode);
             
            // Rotation <rotation pitch=\"0.111\" roll=\"0.221\" yaw=\"0.341\"/>"
            Handle pitchNode = atomSpace.getHandle(NUMBER_NODE, "0.111");
            TS_ASSERT(CoreUtils::compare(pitchNode, Handle::UNDEFINED));
            Handle rollNode = atomSpace.getHandle(NUMBER_NODE, "0.221");
            TS_ASSERT(CoreUtils::compare(rollNode, Handle::UNDEFINED));
            Handle yawNode = atomSpace.getHandle(NUMBER_NODE, "0.341");
            TS_ASSERT(CoreUtils::compare(yawNode, Handle::UNDEFINED));
            HandleSeq rotateListLinkOutgoing;
            rotateListLinkOutgoing.push_back(pitchNode); 
            rotateListLinkOutgoing.push_back(rollNode); 
            rotateListLinkOutgoing.push_back(yawNode); 
            Handle rotateListLink = atomSpace.getHandle(LIST_LINK, rotateListLinkOutgoing);
            parametersListLink.push_back(rotateListLink);
            
	    predicateListLinkOutgoing.push_back( atomSpace.getHandle(LIST_LINK, parametersListLink ) );

            Handle predicateListLink = atomSpace.getHandle(LIST_LINK, predicateListLinkOutgoing);
            TS_ASSERT(CoreUtils::compare(predicateListLink, Handle::UNDEFINED));

            HandleSeq evalLinkOutgoing;
            evalLinkOutgoing.push_back(predNode);
            evalLinkOutgoing.push_back(predicateListLink);
            Handle evalLink = atomSpace.getHandle(EVALUATION_LINK, evalLinkOutgoing);
            TS_ASSERT(CoreUtils::compare(evalLink, Handle::UNDEFINED));
        }

        // Check Agent-signal atoms (avatar)
        {
            cout << "checking agent signals" << endl;
            
            Handle predNode = atomSpace.getHandle(PREDICATE_NODE, ACTION_DONE_PREDICATE_NAME);
            TS_ASSERT(CoreUtils::compare(predNode, Handle::UNDEFINED));

            HandleSeq predicateListLinkOutgoing;
            
            // Agent node 
            Handle agentNode = atomSpace.getHandle(SL_AVATAR_NODE, PAIUtils::getInternalId("9").c_str());
            TS_ASSERT(CoreUtils::compare(agentNode, Handle::UNDEFINED));
            predicateListLinkOutgoing.push_back(agentNode);
            
            // Action node
            Handle actionNode = atomSpace.getHandle(NODE, "walk");
            TS_ASSERT(CoreUtils::compare(actionNode, Handle::UNDEFINED));
            predicateListLinkOutgoing.push_back(actionNode);

	    HandleSeq parametersListLink;

            // Vector <vector x=\"1.01\" y=\"1.77\" z=\"2.1\"/>"
            Handle xNode = atomSpace.getHandle(NUMBER_NODE, "1.01");
            TS_ASSERT(CoreUtils::compare(xNode, Handle::UNDEFINED));
            Handle yNode = atomSpace.getHandle(NUMBER_NODE, "1.77");
            TS_ASSERT(CoreUtils::compare(yNode, Handle::UNDEFINED));
            Handle zNode = atomSpace.getHandle(NUMBER_NODE, "2.1");
            TS_ASSERT(CoreUtils::compare(zNode, Handle::UNDEFINED));
            HandleSeq targetListLinkOutgoing;
            targetListLinkOutgoing.push_back(xNode); 
            targetListLinkOutgoing.push_back(yNode); 
            targetListLinkOutgoing.push_back(zNode); 
            Handle targetListLink = atomSpace.getHandle(LIST_LINK, targetListLinkOutgoing);
            parametersListLink.push_back(targetListLink);
            
            // Speed <param name=\"speed\" type=\"float\" value=\"8.5\"/>"
            Handle speedNode = atomSpace.getHandle(NUMBER_NODE, "8.5");
            TS_ASSERT(CoreUtils::compare(speedNode, Handle::UNDEFINED));
            parametersListLink.push_back(speedNode);
             
            // Rotation <rotation pitch=\"0.3274\" roll=\"0.517\" yaw=\"0.87\"/>"
            Handle pitchNode = atomSpace.getHandle(NUMBER_NODE, "0.3274");
            TS_ASSERT(CoreUtils::compare(pitchNode, Handle::UNDEFINED));
            Handle rollNode = atomSpace.getHandle(NUMBER_NODE, "0.517");
            TS_ASSERT(CoreUtils::compare(rollNode, Handle::UNDEFINED));
            Handle yawNode = atomSpace.getHandle(NUMBER_NODE, "0.87");
            TS_ASSERT(CoreUtils::compare(yawNode, Handle::UNDEFINED));
            HandleSeq rotateListLinkOutgoing;
            rotateListLinkOutgoing.push_back(pitchNode); 
            rotateListLinkOutgoing.push_back(rollNode); 
            rotateListLinkOutgoing.push_back(yawNode); 
            Handle rotateListLink = atomSpace.getHandle(LIST_LINK, rotateListLinkOutgoing);
            parametersListLink.push_back(rotateListLink);
            
	    predicateListLinkOutgoing.push_back( atomSpace.getHandle(LIST_LINK, parametersListLink ) );

            Handle predicateListLink = atomSpace.getHandle(LIST_LINK, predicateListLinkOutgoing);
            TS_ASSERT(CoreUtils::compare(predicateListLink, Handle::UNDEFINED));

            HandleSeq evalLinkOutgoing;
            evalLinkOutgoing.push_back(predNode);
            evalLinkOutgoing.push_back(predicateListLink);
            Handle evalLink = atomSpace.getHandle(EVALUATION_LINK, evalLinkOutgoing);
            TS_ASSERT(CoreUtils::compare(evalLink, Handle::UNDEFINED));
        }



        
        // Check object-signal atoms
        {
            cout << "checking object signals" << endl;
            
            Handle objectNode = atomSpace.getHandle(SL_OBJECT_NODE, PAIUtils::getInternalId("Stick").c_str());
            TS_ASSERT(CoreUtils::compare(objectNode, Handle::UNDEFINED));
            Handle actionNode = atomSpace.getHandle(WORD_NODE, "attached");
            TS_ASSERT(CoreUtils::compare(actionNode, Handle::UNDEFINED));

            // State predicates
            {
                Handle predNode = atomSpace.getHandle(PREDICATE_NODE, "ObjectState");
                TS_ASSERT(CoreUtils::compare(predNode, Handle::UNDEFINED));
    
                {
                    Handle paramNameNode = atomSpace.getHandle(NODE, "avatar-id");
                    TS_ASSERT(CoreUtils::compare(paramNameNode, Handle::UNDEFINED));
                    Handle paramValueNode = atomSpace.getHandle(NODE, "Wynx"); // This is not converted to internal id. Should it be? If so what other param names (besides avatar-id) must be handled the same way? 
                    TS_ASSERT(CoreUtils::compare(paramValueNode, Handle::UNDEFINED));
                    
                    HandleSeq paramListLinkOutgoing;
                    paramListLinkOutgoing.push_back(paramNameNode);
                    paramListLinkOutgoing.push_back(paramValueNode);
                    Handle paramListLink = atomSpace.getHandle(LIST_LINK, paramListLinkOutgoing);
                    TS_ASSERT(CoreUtils::compare(paramListLink, Handle::UNDEFINED));
        
                    HandleSeq statePredListLinkOutgoing;
                    statePredListLinkOutgoing.push_back(objectNode);
                    statePredListLinkOutgoing.push_back(actionNode);
                    statePredListLinkOutgoing.push_back(paramListLink);
                    Handle statePredListLink = atomSpace.getHandle(LIST_LINK, statePredListLinkOutgoing);
                    TS_ASSERT(CoreUtils::compare(statePredListLink, Handle::UNDEFINED));
    
                    HandleSeq evalLinkOutgoing;
                    evalLinkOutgoing.push_back(predNode);
                    evalLinkOutgoing.push_back(statePredListLink);
                    Handle evalLink = atomSpace.getHandle(EVALUATION_LINK, evalLinkOutgoing);
                    TS_ASSERT(CoreUtils::compare(evalLink, Handle::UNDEFINED));
                }
                

                {
                    Handle paramNameNode = atomSpace.getHandle(NODE, "bodyPart");
                    TS_ASSERT(CoreUtils::compare(paramNameNode, Handle::UNDEFINED));
                    Handle paramValueNode = atomSpace.getHandle(NODE, "RIGHT_HAND");
                    TS_ASSERT(CoreUtils::compare(paramValueNode, Handle::UNDEFINED));
                    
                    HandleSeq paramListLinkOutgoing;
                    paramListLinkOutgoing.push_back(paramNameNode);
                    paramListLinkOutgoing.push_back(paramValueNode);
                    Handle paramListLink = atomSpace.getHandle(LIST_LINK, paramListLinkOutgoing);
                    TS_ASSERT(CoreUtils::compare(paramListLink, Handle::UNDEFINED));
        
                    HandleSeq statePredListLinkOutgoing;
                    statePredListLinkOutgoing.push_back(objectNode);
                    statePredListLinkOutgoing.push_back(actionNode);
                    statePredListLinkOutgoing.push_back(paramListLink);
                    Handle statePredListLink = atomSpace.getHandle(LIST_LINK, statePredListLinkOutgoing);
                    TS_ASSERT(CoreUtils::compare(statePredListLink, Handle::UNDEFINED));
    
                    HandleSeq evalLinkOutgoing;
                    evalLinkOutgoing.push_back(predNode);
                    evalLinkOutgoing.push_back(statePredListLink);
                    Handle evalLink = atomSpace.getHandle(EVALUATION_LINK, evalLinkOutgoing);
                    TS_ASSERT(CoreUtils::compare(evalLink, Handle::UNDEFINED));
                }
                
            }
            
            // Position predicate
            {
                Handle predNode = atomSpace.getHandle(PREDICATE_NODE, AGISIM_POSITION_PREDICATE_NAME);
                TS_ASSERT(CoreUtils::compare(predNode, Handle::UNDEFINED));
    
                Handle xNode = atomSpace.getHandle(NUMBER_NODE, "5.05");
                TS_ASSERT(CoreUtils::compare(xNode, Handle::UNDEFINED));
                Handle yNode = atomSpace.getHandle(NUMBER_NODE, "64.25");
                TS_ASSERT(CoreUtils::compare(yNode, Handle::UNDEFINED));
                Handle zNode = atomSpace.getHandle(NUMBER_NODE, "4.25");
                TS_ASSERT(CoreUtils::compare(zNode, Handle::UNDEFINED));
                
                HandleSeq predicateListLinkOutgoing;
                predicateListLinkOutgoing.push_back(objectNode);
                predicateListLinkOutgoing.push_back(xNode);
                predicateListLinkOutgoing.push_back(yNode);
                predicateListLinkOutgoing.push_back(zNode);
                Handle predicateListLink = atomSpace.getHandle(LIST_LINK, predicateListLinkOutgoing);
                TS_ASSERT(CoreUtils::compare(predicateListLink, Handle::UNDEFINED));
                
                HandleSeq evalLinkOutgoing;
                evalLinkOutgoing.push_back(predNode);
                evalLinkOutgoing.push_back(predicateListLink);
                Handle evalLink = atomSpace.getHandle(EVALUATION_LINK, evalLinkOutgoing);
                TS_ASSERT(CoreUtils::compare(evalLink, Handle::UNDEFINED));
            }
            
            // Rotation predicate
            {
                Handle predNode = atomSpace.getHandle(PREDICATE_NODE, "AGISIM_rotation");
                TS_ASSERT(CoreUtils::compare(predNode, Handle::UNDEFINED));
    
                Handle pitchNode = atomSpace.getHandle(NUMBER_NODE, "0");
                TS_ASSERT(CoreUtils::compare(pitchNode, Handle::UNDEFINED));
                Handle rollNode = atomSpace.getHandle(NUMBER_NODE, "0");
                TS_ASSERT(CoreUtils::compare(rollNode, Handle::UNDEFINED));
                Handle yawNode = atomSpace.getHandle(NUMBER_NODE, "2.5");
                TS_ASSERT(CoreUtils::compare(yawNode, Handle::UNDEFINED));
                
                HandleSeq predicateListLinkOutgoing;
                predicateListLinkOutgoing.push_back(objectNode);
                predicateListLinkOutgoing.push_back(pitchNode);
                predicateListLinkOutgoing.push_back(rollNode);
                predicateListLinkOutgoing.push_back(yawNode);
                Handle predicateListLink = atomSpace.getHandle(LIST_LINK, predicateListLinkOutgoing);
                TS_ASSERT(CoreUtils::compare(predicateListLink, Handle::UNDEFINED));
                
                HandleSeq evalLinkOutgoing;
                evalLinkOutgoing.push_back(predNode);
                evalLinkOutgoing.push_back(predicateListLink);
                Handle evalLink = atomSpace.getHandle(EVALUATION_LINK, evalLinkOutgoing);
                TS_ASSERT(CoreUtils::compare(evalLink, Handle::UNDEFINED));
            }
            
        }
 
        // Check map-info atoms
        {
            cout << "checking map info" << endl;

            // entities
            Handle wynxNode = atomSpace.getHandle(SL_AVATAR_NODE, PAIUtils::getInternalId("2").c_str());
            TS_ASSERT(CoreUtils::compare(wynxNode, Handle::UNDEFINED));
            Handle stickNode = atomSpace.getHandle(SL_ACCESSORY_NODE, PAIUtils::getInternalId("Stick"));
            TS_ASSERT(CoreUtils::compare(stickNode, Handle::UNDEFINED));
            Handle whistleNode = atomSpace.getHandle(SL_ACCESSORY_NODE, PAIUtils::getInternalId("whistle").c_str());
            TS_ASSERT(CoreUtils::compare(whistleNode, Handle::UNDEFINED));
            Handle fidoNode = atomSpace.getHandle(SL_PET_NODE, PAIUtils::getInternalId("1").c_str());
            TS_ASSERT(CoreUtils::compare(fidoNode, Handle::UNDEFINED));
            Handle homeNode = atomSpace.getHandle(SL_STRUCTURE_NODE, PAIUtils::getInternalId("house").c_str());
            TS_ASSERT(CoreUtils::compare(homeNode, Handle::UNDEFINED));
            Handle foodBowlNode = atomSpace.getHandle(SL_STRUCTURE_NODE, PAIUtils::getInternalId("bow").c_str());
            TS_ASSERT(CoreUtils::compare(foodBowlNode, Handle::UNDEFINED));
            Handle waterBowlNode = atomSpace.getHandle(SL_STRUCTURE_NODE, PAIUtils::getInternalId("Water bow").c_str());
            TS_ASSERT(CoreUtils::compare(waterBowlNode, Handle::UNDEFINED));


            TS_ASSERT(!AtomSpaceUtil::isPredicateTrue(atomSpace,
                                                      "is_drinkable", 
                                                      whistleNode));
            TS_ASSERT(AtomSpaceUtil::isPredicateTrue(atomSpace, 
                                                     "is_edible", 
                                                     whistleNode));
            
            // check is_moving predicates
            TS_ASSERT(!AtomSpaceUtil::isPredicateTrue(atomSpace,
                                                      "is_moving", 
                                                      waterBowlNode));
            TS_ASSERT(AtomSpaceUtil::isPredicateTrue(atomSpace, 
                                                     "is_moving", 
                                                     whistleNode));

            HandleSeq seq;
            seq.push_back(homeNode);
            seq.push_back(atomSpace.addNode(CONCEPT_NODE, "pet_home"));

            vector<Handle> handles;
            atomSpace.getHandleSet(back_inserter(handles), seq, NULL, NULL, 2,
                                   INHERITANCE_LINK, false);
            TS_ASSERT(handles.size() == 1);

            seq.clear();
            seq.push_back(foodBowlNode);
            seq.push_back(atomSpace.addNode(CONCEPT_NODE, "food_bowl"));

            handles.clear();
            atomSpace.getHandleSet(back_inserter(handles), seq, NULL, NULL, 2,
                                   INHERITANCE_LINK, false);
            //printf("Handles.size() %d\n", handles.size());
            TS_ASSERT(handles.size() == 1);

            seq.clear();
            seq.push_back(waterBowlNode);
            seq.push_back(atomSpace.addNode(CONCEPT_NODE, "water_bowl"));

            handles.clear();
            atomSpace.getHandleSet(back_inserter(handles), seq, NULL, NULL, 2,
                                   INHERITANCE_LINK, false);

            //printf("Handles.size() %d\n", handles.size());
            TS_ASSERT(handles.size() == 1);



            // entity types
            Handle avatarNode = atomSpace.getHandle(NODE, "avatar");
            TS_ASSERT(CoreUtils::compare(avatarNode, Handle::UNDEFINED));
            Handle accessoryNode = atomSpace.getHandle(NODE, "accessory");
            TS_ASSERT(CoreUtils::compare(accessoryNode, Handle::UNDEFINED));
            Handle petNode = atomSpace.getHandle(NODE, "pet");
            TS_ASSERT(CoreUtils::compare(petNode, Handle::UNDEFINED));
            
            // Inheritance links
            {
                HandleSeq inhLinkOutgoing;
                inhLinkOutgoing.push_back(wynxNode); 
                inhLinkOutgoing.push_back(avatarNode);
                Handle inhLink = atomSpace.getHandle(INHERITANCE_LINK, inhLinkOutgoing);  
                TS_ASSERT(CoreUtils::compare(inhLink, Handle::UNDEFINED));
            }
            {    
                HandleSeq inhLinkOutgoing;
                inhLinkOutgoing.push_back(stickNode); 
                inhLinkOutgoing.push_back(accessoryNode);
                Handle inhLink = atomSpace.getHandle(INHERITANCE_LINK, inhLinkOutgoing);  
                TS_ASSERT(CoreUtils::compare(inhLink, Handle::UNDEFINED));
            }
            {    
                HandleSeq inhLinkOutgoing;
                inhLinkOutgoing.push_back(whistleNode); 
                inhLinkOutgoing.push_back(accessoryNode);
                Handle inhLink = atomSpace.getHandle(INHERITANCE_LINK, inhLinkOutgoing);  
                TS_ASSERT(CoreUtils::compare(inhLink, Handle::UNDEFINED));
            }
            {
                HandleSeq inhLinkOutgoing;
                inhLinkOutgoing.push_back(fidoNode); 
                inhLinkOutgoing.push_back(petNode);
                Handle inhLink = atomSpace.getHandle(INHERITANCE_LINK, inhLinkOutgoing);  
                TS_ASSERT(CoreUtils::compare(inhLink, Handle::UNDEFINED));
            }
                     
            // Position predicates
            {
                Handle predNode = atomSpace.getHandle(PREDICATE_NODE, AGISIM_POSITION_PREDICATE_NAME);
                TS_ASSERT(CoreUtils::compare(predNode, Handle::UNDEFINED));
    
                // Wynx: <position x=\"15\" y=\"164\" z=\"14\"/>\n"
                {
                    Handle xNode = atomSpace.getHandle(NUMBER_NODE, "15");
                    TS_ASSERT(CoreUtils::compare(xNode, Handle::UNDEFINED));
                    Handle yNode = atomSpace.getHandle(NUMBER_NODE, "164");
                    TS_ASSERT(CoreUtils::compare(yNode, Handle::UNDEFINED));
                    Handle zNode = atomSpace.getHandle(NUMBER_NODE, "14");
                    TS_ASSERT(CoreUtils::compare(zNode, Handle::UNDEFINED));
                    
                    HandleSeq predicateListLinkOutgoing;
                    predicateListLinkOutgoing.push_back(wynxNode);
                    predicateListLinkOutgoing.push_back(xNode);
                    predicateListLinkOutgoing.push_back(yNode);
                    predicateListLinkOutgoing.push_back(zNode);
                    Handle predicateListLink = atomSpace.getHandle(LIST_LINK, predicateListLinkOutgoing);
                    TS_ASSERT(CoreUtils::compare(predicateListLink, Handle::UNDEFINED));
                    
                    HandleSeq evalLinkOutgoing;
                    evalLinkOutgoing.push_back(predNode);
                    evalLinkOutgoing.push_back(predicateListLink);
                    Handle evalLink = atomSpace.getHandle(EVALUATION_LINK, evalLinkOutgoing);
                    TS_ASSERT(CoreUtils::compare(evalLink, Handle::UNDEFINED));
                }
                
                // Stick: <position x=\"5.051\" y=\"64.251\" z=\"4.251\"/>\n"
                {
                    Handle xNode = atomSpace.getHandle(NUMBER_NODE, "5.051");
                    TS_ASSERT(CoreUtils::compare(xNode, Handle::UNDEFINED));
                    Handle yNode = atomSpace.getHandle(NUMBER_NODE, "64.251");
                    TS_ASSERT(CoreUtils::compare(yNode, Handle::UNDEFINED));
                    Handle zNode = atomSpace.getHandle(NUMBER_NODE, "4.251");
                    TS_ASSERT(CoreUtils::compare(zNode, Handle::UNDEFINED));
                    
                    HandleSeq predicateListLinkOutgoing;
                    predicateListLinkOutgoing.push_back(stickNode);
                    predicateListLinkOutgoing.push_back(xNode);
                    predicateListLinkOutgoing.push_back(yNode);
                    predicateListLinkOutgoing.push_back(zNode);
                    Handle predicateListLink = atomSpace.getHandle(LIST_LINK, predicateListLinkOutgoing);
                    TS_ASSERT(CoreUtils::compare(predicateListLink, Handle::UNDEFINED));
                    
                    HandleSeq evalLinkOutgoing;
                    evalLinkOutgoing.push_back(predNode);
                    evalLinkOutgoing.push_back(predicateListLink);
                    Handle evalLink = atomSpace.getHandle(EVALUATION_LINK, evalLinkOutgoing);
                    TS_ASSERT(CoreUtils::compare(evalLink, Handle::UNDEFINED));
                }

                // Whistle: <position x=\"5.052\" y=\"64.252\" z=\"4.252\"/>\n"
                {
                    Handle xNode = atomSpace.getHandle(NUMBER_NODE, "5.052");
                    TS_ASSERT(CoreUtils::compare(xNode, Handle::UNDEFINED));
                    Handle yNode = atomSpace.getHandle(NUMBER_NODE, "64.252");
                    TS_ASSERT(CoreUtils::compare(yNode, Handle::UNDEFINED));
                    Handle zNode = atomSpace.getHandle(NUMBER_NODE, "4.252");
                    TS_ASSERT(CoreUtils::compare(zNode, Handle::UNDEFINED));
                    
                    HandleSeq predicateListLinkOutgoing;
                    predicateListLinkOutgoing.push_back(whistleNode);
                    predicateListLinkOutgoing.push_back(xNode);
                    predicateListLinkOutgoing.push_back(yNode);
                    predicateListLinkOutgoing.push_back(zNode);
                    Handle predicateListLink = atomSpace.getHandle(LIST_LINK, predicateListLinkOutgoing);
                    TS_ASSERT(CoreUtils::compare(predicateListLink, Handle::UNDEFINED));
                    
                    HandleSeq evalLinkOutgoing;
                    evalLinkOutgoing.push_back(predNode);
                    evalLinkOutgoing.push_back(predicateListLink);
                    Handle evalLink = atomSpace.getHandle(EVALUATION_LINK, evalLinkOutgoing);
                    TS_ASSERT(CoreUtils::compare(evalLink, Handle::UNDEFINED));
                }

                // Fido: <position x=\"25\" y=\"165\" z=\"23.2\"/>\n"
                {
                    Handle xNode = atomSpace.getHandle(NUMBER_NODE, "25");
                    TS_ASSERT(CoreUtils::compare(xNode, Handle::UNDEFINED));
                    Handle yNode = atomSpace.getHandle(NUMBER_NODE, "165");
                    TS_ASSERT(CoreUtils::compare(yNode, Handle::UNDEFINED));
                    Handle zNode = atomSpace.getHandle(NUMBER_NODE, "23.2");
                    TS_ASSERT(CoreUtils::compare(zNode, Handle::UNDEFINED));
                    
                    HandleSeq predicateListLinkOutgoing;
                    predicateListLinkOutgoing.push_back(fidoNode);
                    predicateListLinkOutgoing.push_back(xNode);
                    predicateListLinkOutgoing.push_back(yNode);
                    predicateListLinkOutgoing.push_back(zNode);
                    Handle predicateListLink = atomSpace.getHandle(LIST_LINK, predicateListLinkOutgoing);
                    TS_ASSERT(CoreUtils::compare(predicateListLink, Handle::UNDEFINED));
                    
                    HandleSeq evalLinkOutgoing;
                    evalLinkOutgoing.push_back(predNode);
                    evalLinkOutgoing.push_back(predicateListLink);
                    Handle evalLink = atomSpace.getHandle(EVALUATION_LINK, evalLinkOutgoing);
                    TS_ASSERT(CoreUtils::compare(evalLink, Handle::UNDEFINED));
                }
                
            } // positions
            
            // Rotation predicate
            {
                Handle predNode = atomSpace.getHandle(PREDICATE_NODE, "AGISIM_rotation");
                TS_ASSERT(CoreUtils::compare(predNode, Handle::UNDEFINED));

                // Wynx: <rotation pitch=\"0.01\" roll=\"0.02\" yaw=\"2.53\"/> 
                {    
                    Handle pitchNode = atomSpace.getHandle(NUMBER_NODE, "0.01");
                    TS_ASSERT(CoreUtils::compare(pitchNode, Handle::UNDEFINED));
                    Handle rollNode = atomSpace.getHandle(NUMBER_NODE, "0.02");
                    TS_ASSERT(CoreUtils::compare(rollNode, Handle::UNDEFINED));
                    Handle yawNode = atomSpace.getHandle(NUMBER_NODE, "2.53");
                    TS_ASSERT(CoreUtils::compare(yawNode, Handle::UNDEFINED));
                    
                    HandleSeq predicateListLinkOutgoing;
                    predicateListLinkOutgoing.push_back(wynxNode);
                    predicateListLinkOutgoing.push_back(pitchNode);
                    predicateListLinkOutgoing.push_back(rollNode);
                    predicateListLinkOutgoing.push_back(yawNode);
                    Handle predicateListLink = atomSpace.getHandle(LIST_LINK, predicateListLinkOutgoing);
                    TS_ASSERT(CoreUtils::compare(predicateListLink, Handle::UNDEFINED));
                    
                    HandleSeq evalLinkOutgoing;
                    evalLinkOutgoing.push_back(predNode);
                    evalLinkOutgoing.push_back(predicateListLink);
                    Handle evalLink = atomSpace.getHandle(EVALUATION_LINK, evalLinkOutgoing);
                    TS_ASSERT(CoreUtils::compare(evalLink, Handle::UNDEFINED));
                }
                
                // Stick: <rotation pitch=\"10\" roll=\"10\" yaw=\"12.5\"/>\n"
                {    
                    Handle pitchNode = atomSpace.getHandle(NUMBER_NODE, "10");
                    TS_ASSERT(CoreUtils::compare(pitchNode, Handle::UNDEFINED));
                    Handle rollNode = atomSpace.getHandle(NUMBER_NODE, "10");
                    TS_ASSERT(CoreUtils::compare(rollNode, Handle::UNDEFINED));
                    Handle yawNode = atomSpace.getHandle(NUMBER_NODE, "12.5");
                    TS_ASSERT(CoreUtils::compare(yawNode, Handle::UNDEFINED));
                    
                    HandleSeq predicateListLinkOutgoing;
                    predicateListLinkOutgoing.push_back(stickNode);
                    predicateListLinkOutgoing.push_back(pitchNode);
                    predicateListLinkOutgoing.push_back(rollNode);
                    predicateListLinkOutgoing.push_back(yawNode);
                    Handle predicateListLink = atomSpace.getHandle(LIST_LINK, predicateListLinkOutgoing);
                    TS_ASSERT(CoreUtils::compare(predicateListLink, Handle::UNDEFINED));
                    
                    HandleSeq evalLinkOutgoing;
                    evalLinkOutgoing.push_back(predNode);
                    evalLinkOutgoing.push_back(predicateListLink);
                    Handle evalLink = atomSpace.getHandle(EVALUATION_LINK, evalLinkOutgoing);
                    TS_ASSERT(CoreUtils::compare(evalLink, Handle::UNDEFINED));
                }

                // Whistle: <rotation pitch=\"20\" roll=\"20\" yaw=\"22.5\"/>\n"
                {    
                    Handle pitchNode = atomSpace.getHandle(NUMBER_NODE, "20");
                    TS_ASSERT(CoreUtils::compare(pitchNode, Handle::UNDEFINED));
                    Handle rollNode = atomSpace.getHandle(NUMBER_NODE, "20");
                    TS_ASSERT(CoreUtils::compare(rollNode, Handle::UNDEFINED));
                    Handle yawNode = atomSpace.getHandle(NUMBER_NODE, "22.5");
                    TS_ASSERT(CoreUtils::compare(yawNode, Handle::UNDEFINED));
                    
                    HandleSeq predicateListLinkOutgoing;
                    predicateListLinkOutgoing.push_back(whistleNode);
                    predicateListLinkOutgoing.push_back(pitchNode);
                    predicateListLinkOutgoing.push_back(rollNode);
                    predicateListLinkOutgoing.push_back(yawNode);
                    Handle predicateListLink = atomSpace.getHandle(LIST_LINK, predicateListLinkOutgoing);
                    TS_ASSERT(CoreUtils::compare(predicateListLink, Handle::UNDEFINED));
                    
                    HandleSeq evalLinkOutgoing;
                    evalLinkOutgoing.push_back(predNode);
                    evalLinkOutgoing.push_back(predicateListLink);
                    Handle evalLink = atomSpace.getHandle(EVALUATION_LINK, evalLinkOutgoing);
                    TS_ASSERT(CoreUtils::compare(evalLink, Handle::UNDEFINED));
                }

                // Fido: <rotation pitch=\"30\" roll=\"30\" yaw=\"182.5\"/>\n"
                {    
                    Handle pitchNode = atomSpace.getHandle(NUMBER_NODE, "30");
                    TS_ASSERT(CoreUtils::compare(pitchNode, Handle::UNDEFINED));
                    Handle rollNode = atomSpace.getHandle(NUMBER_NODE, "30");
                    TS_ASSERT(CoreUtils::compare(rollNode, Handle::UNDEFINED));
                    Handle yawNode = atomSpace.getHandle(NUMBER_NODE, "182.5");
                    TS_ASSERT(CoreUtils::compare(yawNode, Handle::UNDEFINED));
                    
                    HandleSeq predicateListLinkOutgoing;
                    predicateListLinkOutgoing.push_back(fidoNode);
                    predicateListLinkOutgoing.push_back(pitchNode);
                    predicateListLinkOutgoing.push_back(rollNode);
                    predicateListLinkOutgoing.push_back(yawNode);
                    Handle predicateListLink = atomSpace.getHandle(LIST_LINK, predicateListLinkOutgoing);
                    TS_ASSERT(CoreUtils::compare(predicateListLink, Handle::UNDEFINED));
                    
                    HandleSeq evalLinkOutgoing;
                    evalLinkOutgoing.push_back(predNode);
                    evalLinkOutgoing.push_back(predicateListLink);
                    Handle evalLink = atomSpace.getHandle(EVALUATION_LINK, evalLinkOutgoing);
                    TS_ASSERT(CoreUtils::compare(evalLink, Handle::UNDEFINED));
                }
                
            } // rotations
        } // map-info

        // process next message        
        string pvpMsg3;
        TS_ASSERT(appendFileContent(PVP_XML_FILE_PATH "/pvpMsg3.xml", pvpMsg3));
        cout << "processing third pvp message (" << PVP_XML_FILE_PATH << "/pvpMsg3.xml" << ")" << endl << pvpMsg3 << endl;
        TS_ASSERT(pai.processPVPMessage(pvpMsg3, toUpdateHandles));

        // Check latest received/processed timestamp
        TS_ASSERT(pai.getLatestSimWorldTimestamp() == PAI::getTimestampFromXsdDateTimeStr("2007-06-18T20:15:04.000-07:00"));

        // Check grab status in PetInterface
        {
            TS_ASSERT(!pai.hasPlanFailed("12"));
            TS_ASSERT(!pai.hasPlanFailed("13"));
            TS_ASSERT(pai.isPlanFinished("12"));
            TS_ASSERT(pai.isPlanFinished("13"));
            
            TS_ASSERT(!pai.getPetInterface().hasGrabbedObj());
            TS_ASSERT(pai.getPetInterface().getGrabbedObj() == string(""));
        }

        // process next message        
        string pvpMsg4;
        TS_ASSERT(appendFileContent(PVP_XML_FILE_PATH "/pvpMsg4.xml", pvpMsg4));
        cout << "processing forth pvp message (" << PVP_XML_FILE_PATH << "/pvpMsg4.xml" << ")" << endl << pvpMsg4 << endl;
        TS_ASSERT(! pai.processPVPMessage(pvpMsg4, toUpdateHandles));

    } // testProcessPVPMessage

    void testTimestampRelatedMethods() {
        unsigned long t1 = PAITestUtil::getCurrentTimestamp();
        sleep(1);
        unsigned long t2 = PAITestUtil::getCurrentTimestamp();
        printf ("t1 = %lu, t2=%lu, delta = %lu\n", t1, t2, t2-t1);
#ifdef DATETIME_DECIMAL_RESOLUTION
        TS_ASSERT(t2 >= t1 + 10); 
        TS_ASSERT(t2 <= t1 + 20); // 1 more second of tolerance 
#else
        // centesimal
        TS_ASSERT(t2 >= t1 + 100); 
        TS_ASSERT(t2 <= t1 + 200); // 1 more second of tolerance 
#endif        

        SystemParameters parameters;
        if(fileExists(parameters.get("CONFIG_FILE").c_str())){
    	    parameters.loadFromFile(parameters.get("CONFIG_FILE"));
        }

        AtomSpace atomSpace;
        
        OKActionPlanSender sender(sentActionPlans);
        PetInterfaceMock petInterface;
        PAI pai(atomSpace, sender, petInterface, parameters);
        petInterface.setPAI(&pai);

/*
        TS_ASSERT(pai.getLatestSimWorldTimestamp() == 0);
        TS_ASSERT(pai.setLatestSimWorldTimestamp(t1));
        TS_ASSERT(pai.getLatestSimWorldTimestamp() == t1);
        TS_ASSERT(pai.setLatestSimWorldTimestamp(t2));
        TS_ASSERT(pai.getLatestSimWorldTimestamp() == t2);
        TS_ASSERT(!pai.setLatestSimWorldTimestamp(t1));
        TS_ASSERT(pai.getLatestSimWorldTimestamp() == t2);
*/

        unsigned long t3 = PAI::getTimestampFromXsdDateTimeStr("2007-06-18T20:00:00.100-07:00");
        unsigned long t4 = PAI::getTimestampFromXsdDateTimeStr("2007-06-19T16:00:00.200-07:00");
        unsigned long t5 = PAI::getTimestampFromXsdDateTimeStr("2007-06-19T23:00:00.200Z");
        unsigned long t6 = PAI::getTimestampFromXsdDateTimeStr("2007-06-19T15:00:00.200-08:00");
        unsigned long t7 = PAI::getTimestampFromXsdDateTimeStr("2007-06-20T01:00:00.200+02:00");
        printf ("t3 = %lu, t4=%lu, delta=%lu\n", t3, t4, t4-t3);
        printf ("20 hours = %lu min, %lu seg, %lu decimals of seg, %lu cent of secs\n", 
                (unsigned long)20*60, (unsigned long)20*60*60, (unsigned long)20*60*60*10, 
                (unsigned long)20*60*60*100);
#ifdef DATETIME_DECIMAL_RESOLUTION
        printf("Decimal resolution\n");
        TS_ASSERT_EQUALS(t3 + 20*60*60*10 + 1, t4);
#else
        TS_ASSERT_EQUALS(t3 + 20*60*60*100 + 10, t4);
#endif        

        // all dateTimes should be the same in UTC time
        TS_ASSERT_EQUALS(t4, t5);
        TS_ASSERT_EQUALS(t4, t6);
        TS_ASSERT_EQUALS(t4, t7);

        unsigned long t8 = PAI::getTimestampFromXsdDateTimeStr("2007-06-18T20:00:00.000-07:00");
        unsigned long t9 = PAI::getTimestampFromXsdDateTimeStr("2007-06-19T16:00:00.000-07:00");

        // Test specific case of detected bug (no second fraction in the timestamp string):
        for (int i = 0; i < 100; i++) {
            unsigned long t10 = PAI::getTimestampFromXsdDateTimeStr("2007-06-18T20:00:00-07:00");
            unsigned long t11 = PAI::getTimestampFromXsdDateTimeStr("2007-06-19T16:00:00-07:00");
            TS_ASSERT_EQUALS(t8,t10); 
            TS_ASSERT_EQUALS(t9,t11); 
        }
/*
        TS_ASSERT(!pai.setLatestSimWorldTimestamp(t3));
        TS_ASSERT(pai.getLatestSimWorldTimestamp() == t2);
        TS_ASSERT(!pai.setLatestSimWorldTimestamp(t4));
        TS_ASSERT(pai.getLatestSimWorldTimestamp() == t2);
*/
        
    }
};


