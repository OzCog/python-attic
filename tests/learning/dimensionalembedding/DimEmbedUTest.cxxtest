/*
 * opencog/tests/learning/dimensionalembedding/DimEmbedUTest.cxxtest
 *
 * Copyright (C) 2010 by Singularity Institute for Artificial Intelligence
 * All Rights Reserved
 *
 * Written by David Crane <dncrane@gmail.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License v3 as
 * published by the Free Software Foundation and including the exceptions
 * at http://opencog.org/wiki/Licenses
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program; if not, write to:
 * Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <cxxtest/TestSuite.h>

#include <opencog/learning/dimensionalembedding/DimEmbedModule.h>
#include <opencog/atomspace/AtomSpace.h>
#include <opencog/atomspace/Node.h>
#include <opencog/atomspace/SimpleTruthValue.h>

using namespace opencog;

class DimEmbedTestSuite : public CxxTest::TestSuite
{
public:        
    void testMisc() {
        AtomSpace *atomSpace = new AtomSpace();
        DimEmbedModule dimEmbed=DimEmbedModule(atomSpace);
        
        Handle h1 = atomSpace->addNode(CONCEPT_NODE, "dog1", SimpleTruthValue(0.001f, 0.00001f));
        Handle h2 = atomSpace->addNode(CONCEPT_NODE, "dog2", SimpleTruthValue(0.001f, 0.00001f));
        Handle h3 = atomSpace->addNode(CONCEPT_NODE, "dog3", SimpleTruthValue(0.001f, 0.00001f));
        Handle h4 = atomSpace->addNode(CONCEPT_NODE, "dog4", SimpleTruthValue(0.001f, 0.00001f));

        atomSpace->addLink(SIMILARITY_LINK, h1, h2,
                           SimpleTruthValue(0.5, SimpleTruthValue::confidenceToCount(1.0)));
        atomSpace->addLink(SIMILARITY_LINK, h1, h3,
                           SimpleTruthValue(0.7, SimpleTruthValue::confidenceToCount(1.0)));
        atomSpace->addLink(SIMILARITY_LINK, h1, h4,
                           SimpleTruthValue(1.0, SimpleTruthValue::confidenceToCount(0.9)));
        atomSpace->addLink(SIMILARITY_LINK, h3, h4,
                           SimpleTruthValue(0.2, SimpleTruthValue::confidenceToCount(1.0)));
        
        dimEmbed.embedAtomSpace(SIMILARITY_LINK, 4);
        dimEmbed.logAtomEmbedding(SIMILARITY_LINK);
        //We have no guarantee on the order that the pivots
        //were picked in, but since numDimensions=numNodes,
        //the euclidean distances between any 2 nodes
        //will not be affected by this.
        //So the embedding vectors should be some permutation of...
        //h1:(1, .5, .7, .9)
        //h2:(.5, 1, .35, .45)
        //h3:(.7, .35, 1, .63)
        //h4:(.9, .45, .63, 1)
        Handle handles[4] = {h1, h2, h3, h4};
        //Pre-calculated distances based on what the embedding should be...
        double dists [4][4] = //dists[i][j] denotes distance between hi and hj
            {{0.0, 0.908295106229, 0.524785670536, 0.165529453572},
             {0.90829510622924747, 0.0, 0.95781000203589439, 0.9183681179135087},
             {0.52478567053607716, 0.95781000203589439, 0.0, 0.5690342696182717},
             {0.16552945357246843, 0.9183681179135087, 0.56903426961827175, 0.0}
            };
        double dist;
        for(int i=0;i<4;i++){
            for(int j=0;j<4;j++){
                dist = dimEmbed.euclidDist(handles[i],
                                                  handles[j]
                                                  ,SIMILARITY_LINK);
                TS_ASSERT_DELTA(dist,dists[i][j],.000001);
            }
        }
        Handle h5 = atomSpace->addNode(CONCEPT_NODE, "dog5", SimpleTruthValue(0.001f, 0.00001f));
        atomSpace->addLink(SIMILARITY_LINK, h1, h5,
                           SimpleTruthValue(0.5, SimpleTruthValue::confidenceToCount(1.0)));
        atomSpace->addLink(SIMILARITY_LINK, h3, h5,
                           SimpleTruthValue(0.6, SimpleTruthValue::confidenceToCount(1.0)));
        dimEmbed.addNode(h5,SIMILARITY_LINK);
        //h1:(1, .5, .7, .9)
        //h3:(.7, .35, 1, .63)
        //So h5 should be some permutation of
        //h5:(.5, .25, .6, .45)
        //so we know what its distance from the others should be
        /*
        std::cout << "h5Embed: ";
        std::vector<double> h5Embed =
            dimEmbed.getEmbedVector(h5,SIMILARITY_LINK);
        for(int i=0;i<h5Embed.size();i++) {
            std::cout << h5Embed[i] << " ";
        } 
        */
        
        TS_ASSERT_DELTA(dimEmbed.euclidDist(h5,h1,SIMILARITY_LINK),
                        0.72456883,
                        .000001);
        TS_ASSERT_DELTA(dimEmbed.euclidDist(h5,h2,SIMILARITY_LINK),
                        0.79056941,
                        .000001);
        TS_ASSERT_DELTA(dimEmbed.euclidDist(h5,h3,SIMILARITY_LINK),
                        0.49234134,
                        .000001);
        TS_ASSERT_DELTA(dimEmbed.euclidDist(h5,h4,SIMILARITY_LINK),
                        0.70950687,
                        .000001);
        delete atomSpace;
    }
    //TODO: Write tests for k nearest neighbor and clustering
};
