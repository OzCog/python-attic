/*
 * opencog/tests/learning/experimental-pattern-miner/c++-based/XPatternMiner.cxxtest
 *
 * Copyright (C) 2017 by OpenCog Foundation
 * All Rights Reserved
 *
 * Written by Nil Geisweiller
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License v3 as
 * published by the Free Software Foundation and including the exceptions
 * at http://opencog.org/wiki/Licenses
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program; if not, write to:
 * Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <cxxtest/TestSuite.h>

#include <opencog/util/Config.h>
#include <opencog/atomspace/AtomSpace.h>
#include <opencog/learning/experimental-pattern-miner/c++-based/XPatternMiner.h>
#include <opencog/guile/SchemeEval.h>

#include <vector>

using namespace opencog;
using namespace std;

#define al _as.add_link
#define an _as.add_node

class XPatternMinerUTest : public CxxTest::TestSuite
{
private:
	AtomSpace _as;
	AtomSpace _tmp_as;
	SchemeEval _scm;

public:
	XPatternMinerUTest();
	~XPatternMinerUTest();

	void setUp();
	void tearDown();

	void test_product_compose();

	void test_A();
	void test_AB_AC();
	void test_AB_AC_BC();
	void test_AB_ABC();
	// void test_InferenceControl();
};

XPatternMinerUTest::XPatternMinerUTest() : _scm(&_as)
{
	logger().set_level(Logger::DEBUG);
	logger().set_timestamp_flag(false);
	logger().set_print_to_stdout_flag(true);
}
XPatternMinerUTest::~XPatternMinerUTest() {}

void XPatternMinerUTest::setUp()
{
	// Configure scheme load-paths that are common for all tests.
	_scm.eval("(add-to-load-path \"" PROJECT_SOURCE_DIR
	          "/tests/learning/experimental-pattern-miner/C++-based/XPatternMiner\")");
}

void XPatternMinerUTest::tearDown()
{
	_as.clear();
	_tmp_as.clear();
}

void XPatternMinerUTest::test_product_compose()
{
	logger().info("BEGIN TEST: %s", __FUNCTION__);

	XPatternMiner pm(_as);

	Handle X = _tmp_as.add_node(VARIABLE_NODE, "$X"),
		Y = _tmp_as.add_node(VARIABLE_NODE, "$Y"),
		a = _tmp_as.add_node(CONCEPT_NODE, "a"),
		b = _tmp_as.add_node(CONCEPT_NODE, "b"),
		c = _tmp_as.add_node(CONCEPT_NODE, "c"),
		d = _tmp_as.add_node(CONCEPT_NODE, "d"),
		Sac = _tmp_as.add_link(SET_LINK, a, c),
		XY = _tmp_as.add_link(LAMBDA_LINK, _tmp_as.add_link(VARIABLE_LIST, X, Y),
		                      _tmp_as.add_link(INHERITANCE_LINK, X, Y)),
		Xb = _tmp_as.add_link(LAMBDA_LINK, X,
		                      _tmp_as.add_link(INHERITANCE_LINK, X, b)),
		Xd = _tmp_as.add_link(LAMBDA_LINK, X,
		                      _tmp_as.add_link(INHERITANCE_LINK, X, d)),
		aY = _tmp_as.add_link(LAMBDA_LINK, Y,
		                      _tmp_as.add_link(INHERITANCE_LINK, a, Y)),
		ab = _tmp_as.add_link(INHERITANCE_LINK, a, b),
		ad = _tmp_as.add_link(INHERITANCE_LINK, a, d),
		SacY = _tmp_as.add_link(LAMBDA_LINK, Y,
		                        _tmp_as.add_link(INHERITANCE_LINK, Sac, Y)),
		Sacb = _tmp_as.add_link(INHERITANCE_LINK, Sac, b),
		Sacd = _tmp_as.add_link(INHERITANCE_LINK, Sac, d);

	HandleMultimap var2pats = { {X, {a, Sac}}, {Y, {b, d}} };

	const HandleUCounter texts; // it can be empty since minsup is null
	HandleSet results = pm.product_compose(XY, texts, var2pats),
		expected = { Xb, Xd, aY, ab, ad, SacY, Sacb, Sacd };

	logger().debug() << "results = " << oc_to_string(results);
	logger().debug() << "expected = " << oc_to_string(expected);

	TS_ASSERT(content_eq(results, expected));
}

void XPatternMinerUTest::test_A()
{
	logger().info("BEGIN TEST: %s", __FUNCTION__);

	Handle A = an(CONCEPT_NODE, "A");

	XPMParameters param(2);
	XPatternMiner pm(_as, param);
	HandleSet results = pm(),
		expected;

	logger().debug() << "results = " << oc_to_string(results);
	logger().debug() << "expected = " << oc_to_string(expected);

	TS_ASSERT(content_eq(results, expected));
}

void XPatternMinerUTest::test_AB_AC()
{
	logger().info("BEGIN TEST: %s", __FUNCTION__);

	Handle A = an(CONCEPT_NODE, "A"),
		B = an(CONCEPT_NODE, "B"),
		C = an(CONCEPT_NODE, "C"),
		AB = al(INHERITANCE_LINK, A, B),
		AC = al(INHERITANCE_LINK, A, C);

	XPMParameters param(2);
	XPatternMiner pm(_as, param);
	HandleSet results = pm();

	Handle X = an(VARIABLE_NODE, "$X"),
		Y = an(VARIABLE_NODE, "$Y"),
		XY = al(INHERITANCE_LINK, X, Y),
		AY = al(INHERITANCE_LINK, A, Y);
	HandleSet expected = { al(LAMBDA_LINK, al(VARIABLE_LIST, X, Y), XY),
	                       al(LAMBDA_LINK, Y, AY) };

	logger().debug() << "results = " << oc_to_string(results);
	logger().debug() << "expected = " << oc_to_string(expected);

	TS_ASSERT(content_eq(results, expected));
}

void XPatternMinerUTest::test_AB_AC_BC()
{
	logger().info("BEGIN TEST: %s", __FUNCTION__);

	Handle A = an(CONCEPT_NODE, "A"),
		B = an(CONCEPT_NODE, "B"),
		C = an(CONCEPT_NODE, "C"),
		AB = al(INHERITANCE_LINK, A, B),
		AC = al(INHERITANCE_LINK, A, C),
		BC = al(INHERITANCE_LINK, B, C);

	XPMParameters param(2);
	XPatternMiner pm(_as, param);
	HandleSet results = pm();

	Handle X = an(VARIABLE_NODE, "$X"),
		Y = an(VARIABLE_NODE, "$Y"),
		XY = al(INHERITANCE_LINK, X, Y),
		AY = al(INHERITANCE_LINK, A, Y),
		XC = al(INHERITANCE_LINK, X, C);
	HandleSet expected = { al(LAMBDA_LINK, al(VARIABLE_LIST, X, Y), XY),
	                       al(LAMBDA_LINK, Y, AY),
	                       al(LAMBDA_LINK, X, XC) };

	logger().debug() << "results = " << oc_to_string(results);
	logger().debug() << "expected = " << oc_to_string(expected);

	TS_ASSERT(content_eq(results, expected));
}

void XPatternMinerUTest::test_AB_ABC()
{
	logger().info("BEGIN TEST: %s", __FUNCTION__);

	Handle A = an(CONCEPT_NODE, "A"),
		B = an(CONCEPT_NODE, "B"),
		C = an(CONCEPT_NODE, "C"),
		AB = al(INHERITANCE_LINK, A, B),
		ABC = al(INHERITANCE_LINK, A, al(AND_LINK, B, C));

	XPMParameters param(2);
	XPatternMiner pm(_as, param);
	HandleSet results = pm();

	Handle X = an(VARIABLE_NODE, "$X"),
		Y = an(VARIABLE_NODE, "$Y"),
		XY = al(INHERITANCE_LINK, X, Y),
		AY = al(INHERITANCE_LINK, A, Y);
	HandleSet expected = { al(LAMBDA_LINK, al(VARIABLE_LIST, X, Y), XY),
	                       al(LAMBDA_LINK, Y, AY) };

	logger().debug() << "results = " << oc_to_string(results);
	logger().debug() << "expected = " << oc_to_string(expected);

	TS_ASSERT(content_eq(results, expected));
}

// void XPatternMinerUTest::test_InferenceControl()
// {
// 	logger().info("BEGIN TEST: %s", __FUNCTION__);

// 	// Load inference-control-corpus.scm
// 	std::string rs =
// 		_scm.eval("(load-from-path \"inference-control-corpus.scm\")");

// 	std::cout << "rs = " << rs << std::endl;

// 	// Run the pattern miner
// 	XPatternMiner pm(_as);
// 	HandleSet patterns = pm();

// 	logger().info() << "patterns = " << oc_to_string(patterns);

// 	// The main pattern of interest should look like
// 	//
// 	// Execution
// 	//   Schema "expand"
// 	//   List
// 	//     PatternMiningVariable "$k"
// 	//     Inheritance
// 	//       ConceptNode "A"
// 	//       PatternMiningVariable "$x"
// 	//     GroundedSchemaNode "scm: conditional-full-instantiation-scope-formula"
// 	//   PatternMiningVariable "$r"
// 	//
// 	// Evaluation
// 	//   Predicate "preproof
// 	//   PatternMiningVariable "$k"
// 	//
// 	// Evaluation
// 	//   Predicate "preproof
// 	//   PatternMiningVariable "$r"

// 	TS_WARN("TODO");
// }

// void XPatternMinerUTest::test_PatternMiner_SodaDrinker()
// {
// 	logger().info("BEGIN TEST: %s", __FUNCTION__);
// 	// Load ugly_male_soda-drinker_corpus.scm
// 	_scm.eval("(load-from-path \"ugly_male_soda-drinker_corpus.scm\")");

// 	// Run the pattern miner
// 	PatternMiner pm(_as);
// 	pm.runPatternMiner(false);

// 	// Test the result: check the final top 3-gram pattern

// 	vector<HTreeNode*>& top3gramPatterns = pm.getFinalPatternsForGram(3);

// 	string patternStr = pm.unifiedPatternToKeyString(top3gramPatterns[0]->pattern);
// 	logger().info("The result top 3-gram pattern: \n%s", patternStr.c_str());

// 	if (patternStr != top3gramPatternStr)
// 	{
// 		logger().info("Failed: The result top 3-gram pattern is wrong! The right one should be:\n%s", top3gramPatternStr.c_str());
// 		TS_FAIL("The result top 3-gram pattern is wrong!");
// 	}

// 	if (top3gramPatterns[0]->count != 5)
// 	{
// 		logger().info("Failed: The result top 3-gram pattern count is wrong!");
// 		TS_FAIL("The result top 3-gram pattern count is wrong!");
// 	}

// 	logger().info("End TEST: %s", __FUNCTION__);
// }

#undef al
#undef an
