/*
 * Copyright (C) 2002-2007 Novamente LLC
 * Copyright (C) 2008 by Singularity Institute for Artificial Intelligence
 * All Rights Reserved
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License v3 as
 * published by the Free Software Foundation and including the exceptions
 * at http://opencog.org/wiki/Licenses
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program; if not, write to:
 * Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include "opencog/reasoning/pln/PLN.h"
#include "opencog/reasoning/pln/rules/Rules.h"

#define BackInferenceTreeRootT BITNodeRoot

#include "opencog/reasoning/pln/AtomSpaceWrapper.h"
#include "opencog/reasoning/pln/BackInferenceTreeNode.h"

#include "opencog/reasoning/pln/rules/RuleApp.h"

#include <stdlib.h>
#include <time.h>
#ifndef WIN32
    #include <sys/time.h>
#endif

#include "opencog/reasoning/pln/rules/RuleProvider.h"

#include <opencog/util/Config.h>

using namespace opencog::pln;
using namespace std;

#define RUN_FAILURE_TESTS 0
#define WAIT_KEY_ON_FAILURE 0

// We must use the OPENCOG_SOURCE_DIR var supplied by the CMake script to
// ensure we find the files whether or not we're building using a separate build
// dir
#define PLN_TEST_DIR OPENCOG_SOURCE_DIR"/tests/reasoning/pln/"

#if 0
#include <windows.h>
#include <Mmsystem.h>

#if defined(_MSC_VER) || defined(__MINGW32__)
#  include <time.h>
#ifndef _TIMEVAL_DEFINED /* also in winsock[2].h */
#define _TIMEVAL_DEFINED
struct timeval {
    long tv_sec;
    long tv_usec;
};
#endif /* _TIMEVAL_DEFINED */
#else
#  include <sys/time.h>
#endif

#if defined(_MSC_VER) || defined(__MINGW32__)
int gettimeofday(struct timeval* tp, void* tzp) {
    unsigned long t;
    t = timeGetTime();
    tp->tv_sec = t / 1000;
    tp->tv_usec = t % 1000;
    /* 0 indicates that the call succeeded. */
    return 0;
}
#endif
#endif

namespace test
{
    extern FILE *logfile;
    extern double custom_duration;
    extern double custom_duration2;
}

FitnessEvaluatorT testFitnessEvaluator;
void initAxiomSet(string premiseFile);

// These are now in PLNUtils.h
//#define NewNode(_T, _NAME) mva(nm->addNode(_T, _NAME, TruthValue::TRIVIAL_TV(), false,false))
//#define makemeta(atom_description) meta(new tree<Vertex>(atom_description))

#define maketest(test_description,a,b,c,d) \
    runPLNTest(Btr<PLNTest>(new PLNTest(test_description,a,b,c,d)))

float getCount(float c)
{ return SimpleTruthValue::confidenceToCount(c); }

namespace opencog {
namespace pln {
    extern unsigned long now_interval_len   ;
}}

vector< vector<vector<int> > >  INstatsVT;
vector<vector<int> > INstatsV;
vector<int> INstats;
static int allTestsInferenceNodes=0;

bool foo42=false;

/**
 * The tests load in various xml axiom sets and run until the target with a
 * specific confidence minimum has been reached (or max. nr of steps have been
 * exceeded, resulting in failure.)
 */        
struct PLNTest
{
    meta target;
    TruthValue* minTV, *maxTV;

    uint minEvalsOfFittestBIT; //Divided by ten
    uint minExhaustiveEvals; //Use either this one or the prev one
    PLNTest(meta _target,
            TruthValue* _minTV,
            TruthValue* _maxTV,
            uint _minEvalsOfFittestBIT,
            uint _minExhaustiveEvals)
        : target(_target), minTV(_minTV), maxTV(_maxTV),
          minEvalsOfFittestBIT(_minEvalsOfFittestBIT),
          minExhaustiveEvals(_minExhaustiveEvals)
    {}
};

void runPLNTest(Btr<PLNTest> t);

const float temperatures[] = {
    0.00005, 0.00007, 10,
    0.0001, 0.0003, 0.0005,
    0.001, 0.003, 0.005,
    0.01, 0.03, 0.05,
    0.1, 0.3, 0.5,
    1, 3, 5 };

class PLNUTest :  public CxxTest::TestSuite {

private:
    AtomSpaceWrapper *atw;
    FILE *f;

    // stuff for running tests multiple times,
    // for non-deterministic heuristic functions
    static const int TestRepeats = 1;
    int seed;
    int tempi;
    // test repeat #
    int t;
    
    float temperature;
    static const int temperaturesN = 7; //3*5;

    // Only runs some tests relevant to testing heuristic functions
    void runPLNTestsOnce() {
        // if you want to disable some of these tests,
        // comment out the content in their implementation
        // (so that they won't be run outside of testHeuristic either)
        testTVChecksWork();
        testRandomTVsTooHigh();
        testSymmetricRelationFails();
        testInverseBinding();
        testBasicSpawning();
        testMultipleRootsSpawning();
        testGeneralizationForVariableScopeLink();
        testGeneralizationForForAllLink();
        testInheritanceOsamaAbu();
        testInheritanceMuhummadTerrorist();
        testAnotBdemo();
        testFetchDemo5();
        testFetchDemo5_alt();
        testWoaDemo();        
        
        INstatsV.push_back(INstats);
    }
    
    /**
     * If a nondeterministic function is used for fitness evaluator
     * then try running all the tests with different temperatures/seeds.
     */
    void setupHeuristicTestRun() {
        if (testFitnessEvaluator == BEST)
            return;
    
        INstatsV.clear();

        temperature = temperatures[tempi];

        //time_t seconds;
        //time(&seconds);
        int seconds = 1;
        srand((unsigned int) seconds+(seed++));
        allTestsInferenceNodes = 0;
    }

    void initPLNTests()
    {
        try
        {
            config().load("opencog-test.conf");
        }
        catch (RuntimeException &e)
        {
            std::cerr << e.getMessage() << std::endl;
        }

#if LOG_ON_FILE
        test::logfile=fopen("pln.log","wt");
        cout << "LOGGING TO FILE pln.log!\n";
#endif
        //assert(finger_print_test(*tests[0]) != finger_print_test(*tests[1]));

        // Get config settings from config file.
        // config().set("PLN_LOG_LEVEL","2");
        // config().set("PLN_PRINT_REAL_ATOMS","true");

        testFitnessEvaluator = BEST;
        currentDebugLevel = -4;
    }

    void initAxiomSet(string premiseFile)
    {
        AtomSpaceWrapper *atw = GET_ASW;
        atw->reset();
        atw->allowFWVarsInAtomSpace = true;

        cprintf(-2,"loading...\n");     
        
        atw->archiveTheorems = true;
        bool axioms_ok = atw->loadAxioms(premiseFile);
        assert(axioms_ok);      
        atw->archiveTheorems = false;
        
        cprintf(-2,"%s loaded. Next test: ", premiseFile.c_str());
    }

    void runPLNTest(Btr<PLNTest> t)
    {
        AtomSpaceWrapper *atw = GET_ASW;
        stats::Instance().ITN2atom.clear();

        //currentDebugLevel=0;
        rawPrint(*t->target, t->target->begin(), -2);
        
        clock_t start, finish;
        double duration;

        test::custom_duration = 0.0;
        start = clock();
        
        atw->allowFWVarsInAtomSpace = true;
        
        fflush(stdout);
        //currentDebugLevel=-4;

        Btr<BackInferenceTreeRootT> state(new BITNodeRoot(t->target, new DefaultVariableRuleProvider()));
        uint s_i=0;
        pHandle eh=PHANDLE_UNDEFINED;
        TruthValue* etv = NULL;
        bool passed=false;

        set<VtreeProvider*> eres;

        t->minEvalsOfFittestBIT *= 100; //Minimum "resolution"

        const int expansions_per_run = 1000;

        if (t->minEvalsOfFittestBIT > 0) {
            do {
/*              for (int k=0;k<expansions_per_run;k++)
                    state->expandFittest();
                
                eres = state->evaluate();*/

                cprintf(-3, "\n    Evaluating...\n");
                
                //if (foo42)
                    //currentDebugLevel=4;
                
                int expansions = expansions_per_run;
                eres = state->infer(expansions, 0.000001f, 0.01f);      
                
                if (expansions > 0)
                    cprintf(-3, "Succeeded. Saved $%d / $%d (from the "
                            "beginning of the cycle).\n", expansions,
                            expansions_per_run);
                else
                    cprintf(2, "Failed for now... Saved $%d / $%d (from the "
                            "beginning of the cycle).\n", expansions,
                            expansions_per_run);

                //currentDebugLevel=-4;

                eh = (eres.empty() ? PHANDLE_UNDEFINED :
                        _v2h(*(*eres.rbegin())->getVtree().begin()));

                if (eh != PHANDLE_UNDEFINED )
                    etv = atw->getTV(eh).clone();
//                else
//                    etv = new SimpleTruthValue(0.0f,0.0f);

               /* float c1=t->minTV->getConfidence();
                float c2=t->maxTV->getConfidence();
                float m1=t->minTV->getMean();
                float m2=t->maxTV->getMean(); */

                if (etv) {
                    printf("c: %f min: %f\n", etv->getConfidence(),
                            t->minTV->getConfidence());
                    printf("s: %f min: %f\n", etv->getMean(),
                            t->minTV->getMean());
                    printf("c: %f max: %f\n", etv->getConfidence(),
                            t->maxTV->getConfidence());
                    printf("s: %f max: %f\n", etv->getMean(),
                            t->maxTV->getMean());
                }

                passed = (
                    eh != PHANDLE_UNDEFINED &&
                    etv &&
                    etv->getConfidence() >= t->minTV->getConfidence() &&
                    etv->getMean()       >= t->minTV->getMean() &&
                    etv->getConfidence() <= t->maxTV->getConfidence() &&
                    etv->getMean()       <= t->maxTV->getMean()
                );
        
                cprintf(-4, "TEST Expansion phase %d over.\n", s_i);
            }
            while ((++s_i)*expansions_per_run < t->minEvalsOfFittestBIT
                    && !passed);
        }
        else if (t->minExhaustiveEvals > 0) {
            assert(0);
            /// This should be updated to reflect the new BITNode interface
            /*
            for (uint L=0;L<t->minExhaustiveEvals;L++)
                state->expandNextLevel();

            eres = state->evaluate();
            eh = (eres.empty() ? NULL : v2h(eres.rbegin()->value));
            if (eh) {
                if (etv != NULL) delete etv;
                etv = atw->TV(eh).clone();
            }

            passed = (eh && etv &&
                etv->getConfidence() > t->minTV->getConfidence() &&
                etv->getMean()          > t->minTV->getMean()
                );*/
        }
        else
            puts("ERROR IN TEST SETTINGS");

        if (passed) {
            printf("\n"
                   "**********************************************\n"
                   "passed: %s.\n"
                   "**********************************************\n",
                (etv?etv->toString().c_str():"(null TV)"));

            finish = clock();
            duration = (double)(finish - start) / CLOCKS_PER_SEC;
            printf( "Test took %2.2f seconds TOTAL.\n", duration );

            printf( "Custom test time was %3.3f seconds.\n",
                    test::custom_duration );
            printf( "Custom test time was %3.3f seconds.\n",
                    test::custom_duration2 );
        }
        else {
            printf("\n**********************************************\n"
                   "FAILED: %s!\n"
                   "**********************************************\n",
            (etv?etv->toString().c_str():"(null TV)"));
        }

        printf("Test results: [");
        foreach(VtreeProvider* bv, eres) {
            const TruthValue& tv = atw->getTV(vt2h(*bv));
            if (!tv.isNullTv() && tv.getConfidence()>0.0001f)
                printf("%d ", vt2h(*bv));
        }
        printf("]\n");

        if (passed) {
            allTestsInferenceNodes += state->inferenceNodes;

            INstats.push_back(state->inferenceNodes);

            cout << endl << "Exec pool size: " << state->exec_pool.size();
            cout << endl << "InferenceNodes: " << state->inferenceNodes <<
                    "/" << allTestsInferenceNodes << endl;
        }
        else
            INstats.push_back(0);

/*      if (etv) {
            string stv(etv->toString());
            puts(stv.c_str());
        }*/

        //stats::Instance().print(stats::triviality_filterT());

        TS_ASSERT(passed);
#if WAIT_KEY_ON_FAILURE
        if (!passed)
            getc(stdin);
#endif
        if (etv != NULL) delete etv;
        //atw->reset(NULL);
    }

public:

    static PLNUTest* createSuite() { return new PLNUTest(); }
    static void destroySuite(PLNUTest* suite) { delete suite; }

    PLNUTest()
    {
        // initial values for running tests multiple times
        seed = 11111;
        tempi=0;
        // test repeat #
        t = 0;
        temperature = 0.1f;
    
        // Initialize PLN test environment
        try {
            logger().info("Initializing PLN test env...");

            f = fopen("results.txt","a");
            
            // This access is required to initialise CogServer.
            CogServer& cogserver = static_cast<CogServer&>(server());
            //currentDebugLevel=100;

            atw = GET_ASW;
        }
        catch(std::string s) {
            logger().error("at root level while initializing.");
        }
        catch(PLNexception e)
        {
            logger().error("at root level while initializing.");
        }
        catch(...)
        {
            logger().error("Unknown exception at root level while initializing. ");
        }
        
        // Initialize PLN tests as such
        initPLNTests();

        allTestsInferenceNodes = 0;

        INstats.clear();

        if(RUN_FAILURE_TESTS)
            puts("NOTE! 3 first tests are supposed to fail.");
            
    }
    
    ~PLNUTest()
    {
        // t = test repeat #
        // f = results.txt
        // TestRepeats
        
//        uint t = 0;
//        uint TestRepeats = 1;
    
        // some stats stuff
        INstatsV.push_back(INstats);
    
        INstatsV[t].push_back(allTestsInferenceNodes);
        INstatsVT.push_back(INstatsV);

        for (uint v=0; v < INstatsV[0].size(); v++)
        {
            fprintf(f, "\n");
            for (int t=0; t < ( (testFitnessEvaluator!=BEST) ? TestRepeats : 1); t++)
                fprintf(f, "%d ", INstatsV[t][v]);
        }

        fclose(f);
    }
    
/*    static PLNUTest* DISABLEcreateSuite()
    {
        PLNUTest* test = new PLNUTest();
        test->multipleTestRunsForHeuristic();
        return test;
    }
    
    
    static void DISABLEdestroySuite(PLNUTest* suite) { delete suite; }*/
    
    void setUp()
    {
    }
    
    void tearDown()
    {
    }
    
    void testHeuristic() {
        if (testFitnessEvaluator == BEST)
        return;

        for (int t=0; t < TestRepeats; t++)
        {
            setupHeuristicTestRun();
        
            // run all of the relevant tests
            runPLNTestsOnce();

            INstatsV[t].push_back(allTestsInferenceNodes);

            if (testFitnessEvaluator != SOFTMAX)
            {
                //No need to play with temperatures or multiple test repeats.
                if (testFitnessEvaluator != RANDOM)
                    t = TestRepeats;
                tempi = temperaturesN;
            }

            INstatsVT.push_back(INstatsV);
        }
        exit(0);
    }
    
    // Tries to combine several RuleApps into a "macro rule", which takes one
    // argument but applies several different rules
    void DISABLEtestMacroRuleTest()
    {
        AtomSpaceWrapper *atw = GET_ASW;
        //typedef InversionRule RuleT1;
        //typedef DeductionRule RuleT2;
        iAtomSpaceWrapper* parent = ASW();

    //  DefaultVariableRuleProvider rp;
        InversionRule *invR = new InversionRule(parent, INHERITANCE_LINK);
        DeductionRule<DeductionSimpleFormula> *deduR = new DeductionRule<DeductionSimpleFormula>(parent, INHERITANCE_LINK);

        printf("v0\n");
        vtree v0(mva((pHandle)INHERITANCE_LINK,
                        mva(atw->addNode(CONCEPT_NODE, "Abu", SimpleTruthValue(0.05, 0.01))),
                        mva(atw->addNode(CONCEPT_NODE, "Osama",  SimpleTruthValue(0.01, 0.01)))
                        ));
        printf("v1\n");
        vtree v1(mva((pHandle)INHERITANCE_LINK,
                        mva(atw->addNode(CONCEPT_NODE, "Osama",  SimpleTruthValue(0.01, 0.01))),
                        mva(atw->addNode(CONCEPT_NODE, "AlQaeda",  SimpleTruthValue(0.1, 0.01)))
                        ));
        printf("v2\n");
        vtree v2(mva((pHandle)INHERITANCE_LINK,
                        mva(atw->addNode(CONCEPT_NODE, "AlQaeda",  SimpleTruthValue(0.1, 0.01))),
                        mva(atw->addNode(CONCEPT_NODE, "terrorist",  SimpleTruthValue(0.2, 0.01)))));

        printf("h0\n");
        pHandle h0 = atw->addAtom(v0, 
                SimpleTruthValue(0.40f, getCount(0.80f)));
        printf("h1\n");
        pHandle h1 = atw->addAtom(v1,
                SimpleTruthValue(0.60f, getCount(0.90f)));
        printf("h2\n");
        pHandle h2 = atw->addAtom(v2,
                SimpleTruthValue(0.98f, getCount(0.95f)));

        RuleApp* top    = new RuleApp(deduR);
        RuleApp* child1a= new RuleApp(deduR);

        child1a->Bind(0, new VtreeProviderWrapper(Vertex(h0)));
        child1a->Bind(1, new VtreeProviderWrapper(Vertex(h1)));
        child1a->compute();

        top->Bind(0, child1a);
        top->Bind(1, new VtreeProviderWrapper(Vertex(h2)));

        BoundVertex res1a = top->compute();
        const TruthValue& tvA = atw->getTV(_v2h(res1a.value));
        assert(tvA.getMean() > 0.01);
        assert(tvA.getConfidence() > 0.01);

        RuleApp* topb   = new RuleApp(deduR);
    //  RuleApp* child1b= vtree(Vertex(h0));
        RuleApp* child2b= new RuleApp(deduR);

        child2b->Bind(0, new VtreeProviderWrapper(Vertex(h1)));
        child2b->Bind(1, new VtreeProviderWrapper(Vertex(h2)));
        topb->Bind(0, new VtreeProviderWrapper(Vertex(h0)));
        topb->Bind(1, child2b);

        BoundVertex res1b = topb->compute();
        assert(res1a.value == res1b.value);

        const TruthValue& tvB = atw->getTV(_v2h(res1a.value));
        assert(within(tvB.getMean(), tvA.getMean(), 0.001));
        assert(within(tvB.getConfidence(), tvA.getConfidence(), 0.001));

        RuleApp* top2 = new RuleApp(invR);
        top2->Bind(0, topb);
        RuleApp* top3 = new RuleApp(invR);
        top3->Bind(0, top2);

        const TruthValue& tv2 = atw->getTV(_v2h(top2->compute().value));
        assert(!within(tvB.getMean(), tv2.getMean(), 0.001));
    //  assert(!within(tvB.getConfidence(), tv2.getConfidence(), 0.001));

        const TruthValue& tv3 = atw->getTV(_v2h(top3->compute().value));
        assert( within(tvB.getMean(), tv3.getMean(), 0.001));
        assert( within(tvB.getConfidence(), tv3.getConfidence(), 0.001));


        vector<VtreeProvider*> args;
        args.push_back(new VtreeProviderWrapper(Vertex(h0)));
        args.push_back(new VtreeProviderWrapper(Vertex(h1)));
        args.push_back(new VtreeProviderWrapper(Vertex(h2)));

        RuleApp* topc   = new RuleApp(deduR);
        RuleApp* child2c= new RuleApp(deduR);

        topc->Bind(1, child2c);

        BoundVertex resC = topc->compute(args.begin(), args.end());

        assert(resC.value == res1b.value);
        const TruthValue& tvC = atw->getTV(_v2h(resC.value));
        assert( within(tvB.getMean(), tvC.getMean(), 0.001));
        assert( within(tvB.getConfidence(), tvC.getConfidence(), 0.001));


        RuleApp* topd   = new RuleApp(deduR);
        RuleApp* child1d= new RuleApp(deduR);

        topd->Bind(0, child1d);

        BoundVertex resD = topd->compute(args.begin(), args.end());

        assert(resD.value == res1b.value);
        const TruthValue& tvD = atw->getTV(_v2h(resD.value));
        assert( within(tvB.getMean(), tvD.getMean(), 0.001));
        assert( within(tvB.getConfidence(), tvD.getConfidence(), 0.001));
        printf("finish MacroRuleTest\n");
    }

    void testTVChecksWork() {
        /// The test which is supposed to fail
        if(RUN_FAILURE_TESTS) {
            initAxiomSet(PLN_TEST_DIR"bigdemo.xml");

            puts("\nShould fail. The test for whether TV checks work.\n");

            maketest(makemeta(mva((pHandle)INHERITANCE_LINK,
                            NewNode(CONCEPT_NODE, "AlQaeda"),
                            NewNode(CONCEPT_NODE, "terrorist")
                    )),
                    new SimpleTruthValue(0.95f, getCount(0.90f)),
                    new SimpleTruthValue(0.999f, getCount(0.999f)),
                    50,0);
        }
    }

    void testRandomTVsTooHigh() {
        if(RUN_FAILURE_TESTS) {
            initAxiomSet(PLN_TEST_DIR"smalldemo.xml");

            puts("\nShould fail. The test for whether random TVs come out too high:\n");

            maketest(makemeta(mva((pHandle)EVALUATION_LINK,
                            NewNode(PREDICATE_NODE, "killed"),
                            mva((pHandle)LIST_LINK,
                                        NewNode(FW_VARIABLE_NODE, "$killeri"),
                                        NewNode(CONCEPT_NODE, "Osama")
                                    )
                    )),
                    new SimpleTruthValue(0.5f, getCount(0.5f)),
                    new SimpleTruthValue(0.51f, getCount(0.51f)),
                    10,0);
        }
    }

    void testSymmetricRelationFails() {
        if(RUN_FAILURE_TESTS) {
            puts("\nShould fail.");
            initAxiomSet(PLN_TEST_DIR"smalldemo.xml");
            maketest(makemeta(mva((pHandle)EVALUATION_LINK,
                            NewNode(PREDICATE_NODE, "symmetricRelation"),
                            mva((pHandle)LIST_LINK,
                                        NewNode(CONCEPT_NODE, "Amir"),
                                        NewNode(CONCEPT_NODE, "Osama")
                                    )
                    )),
                    new SimpleTruthValue(0.0f, getCount(0.0f)),
                    new SimpleTruthValue(0.01f, getCount(0.01f)),
                    10,0);
        }
    }
    
    void testInverseBinding()
    {
        puts("\nInverse Binding test\n");
        initAxiomSet(PLN_TEST_DIR"inverse_binding.xml");
        maketest(makemeta(mva((pHandle)EVALUATION_LINK,
                        NewNode(PREDICATE_NODE, "Possible"),
                        mva((pHandle)LIST_LINK,
                            NewNode(FW_VARIABLE_NODE, "$elmerist")
                        )
                    )),
            new SimpleTruthValue(0.01f, getCount(0.01f)),
            new SimpleTruthValue(1.0f, getCount(1.0f)),
            200,0);
    }

    void testBasicSpawning()
    {
        for (int i = 0; i < 5; i++) {
            printf("\nBasic spawning test %d\n", i);
            /// Basic spawning test
            initAxiomSet(PLN_TEST_DIR"smalldemo.xml");
            maketest(makemeta(mva((pHandle)EVALUATION_LINK,
                        NewNode(PREDICATE_NODE, "friendOf"),
                        mva((pHandle)LIST_LINK,
                                    NewNode(CONCEPT_NODE, "Britney"),
                                    NewNode(CONCEPT_NODE, "Amir")
                                ))),
                new SimpleTruthValue(0.78f, getCount(0.39f)),
                new SimpleTruthValue(1.001f, getCount(0.999f)),
                100,0);
        }
    }
    
    void testMultipleRootsSpawning()
    {
        printf("\nTest for multiple roots spawning.\n");
        /// Test for multiple roots spawning
        initAxiomSet(PLN_TEST_DIR"smalldemo.xml");
        maketest(makemeta(mva((pHandle)EVALUATION_LINK,
                        NewNode(PREDICATE_NODE, "killed"),
                        mva((pHandle)LIST_LINK,
                                    NewNode(FW_VARIABLE_NODE, "$killeri"),
                                    NewNode(CONCEPT_NODE, "Osama")
                                )
                )),
                new SimpleTruthValue(0.5f, getCount(0.5f)),
                new SimpleTruthValue(0.999f, getCount(0.999f)),
            10,0);
    }

    void testGeneralizationForVariableScopeLink()
    {
        printf("\nTest Generalization for VARIABLE_SCOPE_LINK.\n");
        /// Test Generalization for VARIABLE_SCOPE_LINK
        initAxiomSet(PLN_TEST_DIR"smalldemo.xml");
        maketest(makemeta(mva((pHandle)VARIABLE_SCOPE_LINK,
                    mva((pHandle)LIST_LINK), //empty dummy
                    mva((pHandle)INHERITANCE_LINK,
                        NewNode(FW_VARIABLE_NODE, "$i"),
                        NewNode(CONCEPT_NODE, "terrorist")
                ))),
                new SimpleTruthValue(0.9f, getCount(0.02f)),
                new SimpleTruthValue(0.999f, getCount(0.999f)),
                10,0);
    }
    
    void testGeneralizationForForAllLink()
    {
        printf("\nTest Generalization for FORALL_LINK.\n");
        /// Test Generalization for FORALL_LINK
        initAxiomSet(PLN_TEST_DIR"smalldemo.xml");
        maketest(makemeta(mva((pHandle)FORALL_LINK,
                    mva((pHandle)LIST_LINK), //empty dummy
                    mva((pHandle)INHERITANCE_LINK,
                        NewNode(FW_VARIABLE_NODE, "$i"),
                        NewNode(CONCEPT_NODE, "terrorist")
                ))),
                new SimpleTruthValue(0.9f, getCount(0.9f)),
                new SimpleTruthValue(0.999f, getCount(0.999f)),
                15,0);
    }

    void testInheritanceOsamaAbu()
    {
        printf("\nTest inheritance Osama/Abu.\n");
        initAxiomSet(PLN_TEST_DIR"smalldemo.xml");
        maketest(makemeta(mva((pHandle)INHERITANCE_LINK,
                              NewNode(CONCEPT_NODE, "Osama"),
                              NewNode(CONCEPT_NODE, "Abu")
                              )),
                 new SimpleTruthValue(0.0001f, getCount(0.90f)),
                 new SimpleTruthValue(0.999f, getCount(1.01f)),
                 40,0);
    }
    
    void testInheritanceMuhummadTerrorist()
    {
        printf("\nTest inheritance Muhummad->Terrorist.\n");
        initAxiomSet(PLN_TEST_DIR"smalldemo.xml");
// Takes a tad too long with bigdemo (but tested, and it works now)
//        initAxiomSet(PLN_TEST_DIR"bigdemo.xml");
        maketest(makemeta(mva((pHandle)INHERITANCE_LINK,
                    NewNode(CONCEPT_NODE, "Muhammad"),
                    NewNode(CONCEPT_NODE, "terrorist")
            )),
            new SimpleTruthValue(0.01f, getCount(0.20f)),
            new SimpleTruthValue(1.01f, getCount(1.01f)),
            460,0);
    }

    void testAnotBdemo()
    {    
        initAxiomSet(PLN_TEST_DIR"AnotBdemo.xml");
        maketest(makemeta(mva((pHandle)EVALUATION_LINK,
                    NewNode(PREDICATE_NODE, "found_under"),
                        mva((pHandle)LIST_LINK,
                            NewNode(CONCEPT_NODE, "toy_6"),
                            NewNode(FW_VARIABLE_NODE, "$1")
                        )
                )),
                new SimpleTruthValue(0.01f, getCount(0.01f)),
                new SimpleTruthValue(1.01f, getCount(1.01f)),
                10000,0);
    }

    void testFetchDemo5()
    {    
        initAxiomSet(PLN_TEST_DIR"fetchdemo5.xml");
        maketest(makemeta(mva((pHandle)EVALUATION_LINK,
                        NewNode(PREDICATE_NODE, "+++")
                    )
                ),
                new SimpleTruthValue(0.01f, getCount(0.01f)),
                new SimpleTruthValue(1.01f, getCount(0.94f)),
                200,0);
    }

    void testFetchDemo5_alt()
    {
        printf("\nTest fetch demo.\n");
        initAxiomSet(PLN_TEST_DIR"fetchdemo5.xml");
        maketest(makemeta(mva((pHandle)EVALUATION_LINK,
                            NewNode(PREDICATE_NODE, "just_done"),
                            mva((pHandle)LIST_LINK,
                                mva((pHandle)EVALUATION_LINK,
                                    NewNode(SCHEMA_NODE, "give"),
                                    mva((pHandle)LIST_LINK,
                                        NewNode(CONCEPT_NODE, "ball"),
                                        NewNode(CONCEPT_NODE, "teacher")
                                    )
                                )                                       
                            )
                        )
                ),
                new SimpleTruthValue(0.01f, getCount(0.01f)),
                new SimpleTruthValue(1.01f, getCount(1.01f)),
                200,0);
    }

    void testWoaDemo()
    {    
        initAxiomSet(PLN_TEST_DIR"woademo.xml");
        maketest(makemeta(mva((pHandle)SIMULTANEOUS_AND_LINK,
                            NewNode(WORD_NODE, "blockword"),
                            NewNode(FW_VARIABLE_NODE, "$blockword_associatee")
                        )),
                new SimpleTruthValue(0.01f, getCount(0.01f)),
                new SimpleTruthValue(1.01f, getCount(1.01f)),
                500,0);
    }
    
    void DISABLEtestFingerPrint(vtree& v)
    {
        BoundVTree bvt(v);
        printf("Finger print: %lu\n", bvt.getFingerPrint());
    }
    
    void testUnifiesWithVariableChangeTo()
    {
        map<pHandle,pHandle> bindings;
        cout << "Testing unification" << endl;

        TS_ASSERT( unifiesWithVariableChangeTo(
                        mva((pHandle)AND_LINK,
                            NewNode(CONCEPT_NODE, "Osama"),
                            NewNode(CONCEPT_NODE, "terrorist")),
                        mva((pHandle)AND_LINK,
                            NewNode(CONCEPT_NODE, "Osama"),
                            NewNode(CONCEPT_NODE, "terrorist")),
                        bindings));

        TS_ASSERT(!unifiesWithVariableChangeTo(
                        mva((pHandle)AND_LINK,
                            NewNode(CONCEPT_NODE, "Osama"),
                            NewNode(CONCEPT_NODE, "terrorist")),
                        mva((pHandle)AND_LINK,
                            NewNode(CONCEPT_NODE, "Osama"),
                            NewNode(CONCEPT_NODE, "terrorist_DIFF")),
                        bindings));

        TS_ASSERT(!unifiesWithVariableChangeTo(
                        mva((pHandle)AND_LINK,
                            NewNode(CONCEPT_NODE, "Osama"),
                            NewNode(CONCEPT_NODE, "terrorist")),
                        mva((pHandle)AND_LINK,
                            NewNode(FW_VARIABLE_NODE, "Osama"),
                            NewNode(CONCEPT_NODE, "terrorist")),
                        bindings));

        TS_ASSERT( unifiesWithVariableChangeTo(
                        mva((pHandle)AND_LINK,
                            NewNode(FW_VARIABLE_NODE, "1"),
                            NewNode(CONCEPT_NODE, "terrorist")),
                        mva((pHandle)AND_LINK,
                            NewNode(FW_VARIABLE_NODE, "2"),
                            NewNode(CONCEPT_NODE, "terrorist")),
                        bindings));

        TS_ASSERT(!unifiesWithVariableChangeTo(
                        mva((pHandle)AND_LINK,
                            NewNode(FW_VARIABLE_NODE, "1"),
                            NewNode(CONCEPT_NODE, "terrorist")),
                        mva((pHandle)AND_LINK,
                            NewNode(FW_VARIABLE_NODE, "2"),
                            NewNode(CONCEPT_NODE, "terrorist_DIFF")),
                        bindings));
        TS_ASSERT(!unifiesWithVariableChangeTo(
                        mva((pHandle)AND_LINK,
                            NewNode(FW_VARIABLE_NODE, "1"),
                            NewNode(CONCEPT_NODE, "terrorist")),
                        mva((pHandle)AND_LINK,
                            NewNode(FW_VARIABLE_NODE, "2"),
                            NewNode(CONCEPT_NODE, "terrorist"),
                            NewNode(CONCEPT_NODE, "terrorist_DIFF")),
                        bindings));
    }

};

// this has basically been reduced to a repository of commented out tests
#if 0
void runPLNTestsOnce()
{
    AtomSpaceWrapper *atw = GET_ASW;
    INstats.clear();

    puts("Starting PLN tests. NOTE! 3 first tests are supposed to fail.");

    //MacroRuleTest();
    puts("Testing atomspacewrapper");
    atw->testAtomSpaceWrapper();

/*
    maketest(makemeta(mva(
            )),
            new SimpleTruthValue(0.01f, getCount(0.90f)),
            new SimpleTruthValue(1.01f, getCount(1.01f)),
            "bigdemo.xml",
            100);
*/

/*
    maketest(makemeta(mva((Handle)EVALUATION_LINK,
                        NewNode(PREDICATE_NODE, "just_done"),
                        mva((Handle)LIST_LINK,
                            mva((Handle)EVALUATION_LINK,
                                NewNode(SCHEMA_NODE, "give"),
                                mva((Handle)LIST_LINK,
                                    NewNode(CONCEPT_NODE, "ball"),
                                    NewNode(CONCEPT_NODE, "teacher")
                                )
                            )                                       
                        )
                    ))),
            new SimpleTruthValue(0.01f, getCount(0.90f)),
            new SimpleTruthValue(1.01f, getCount(1.01f)),
            "fetchdemo4.xml",
            10,0);
*/

/*  maketest(makemeta(mva(
            )),
            new SimpleTruthValue(0.01f, getCount(0.90f)),
            new SimpleTruthValue(1.01f, getCount(1.01f)),
            "bigdemo.xml",
            100);*/



/*  /// Untested with current PLN implementation:

    maketest(makemeta(mva((Handle)EVALUATION_LINK,
                    NewNode(PREDICATE_NODE, "friendOf"),
                    mva((Handle)LIST_LINK,
                                NewNode(CONCEPT_NODE, "Amir"),
                                NewNode(CONCEPT_NODE, "Osama")
                            )
            )),
            new SimpleTruthValue(0.01f, getCount(0.01f)),
            new SimpleTruthValue(1.01f, getCount(1.01f)),
            "bigdemo.xml",
            10,0);

    maketest(makemeta(mva((Handle)EVALUATION_LINK,
                    NewNode(PREDICATE_NODE, "wasKilled"),
                    mva((Handle)LIST_LINK,
                                NewNode(CONCEPT_NODE, "Osama")
                            )
            )),
            new SimpleTruthValue(0.01f, getCount(0.01f)),
            new SimpleTruthValue(1.01f, getCount(1.01f)),
            "bigdemo.xml",
            10,0);
*/
/*      initAxiomSet("bigdemo.xml");
        maketest(makemeta(mva((Handle)EVALUATION_LINK,
                    NewNode(PREDICATE_NODE, "friendOf"),
                    mva((Handle)LIST_LINK,
                                NewNode(FW_VARIABLE_NODE, "$OsamaFriend"),
                                NewNode(CONCEPT_NODE, "Osama")
                            ))),
            new SimpleTruthValue(0.01f, getCount(0.01f)),
            new SimpleTruthValue(1.01f, getCount(1.01f)),
            10,0);*/
/*  maketest(makemeta(mva((Handle)INHERITANCE_LINK,
                    NewNode(CONCEPT_NODE, "Osama"),
                    NewNode(CONCEPT_NODE, "AlQaeda")
            )),
            new SimpleTruthValue(0.01f, getCount(0.01f)),
            new SimpleTruthValue(1.01f, getCount(1.01f)),
            "bigdemo.xml",
            10,0);
    maketest(makemeta(mva((Handle)EVALUATION_LINK,
                    NewNode(PREDICATE_NODE, "killed"),
                    mva((Handle)LIST_LINK,
                                NewNode(FW_VARIABLE_NODE, "$killeri"),
                                NewNode(CONCEPT_NODE, "Osama")
                            )
            )),
            new SimpleTruthValue(0.01f, getCount(0.01f)),
            new SimpleTruthValue(1.01f, getCount(1.01f)),
            "bigdemo.xml",
            10,0);
    maketest(makemeta(mva((Handle)EVALUATION_LINK,
                        NewNode(PREDICATE_NODE, "do"),
                        mva((Handle)LIST_LINK,
                            mva((Handle)EVALUATION_LINK,
                                NewNode(SCHEMA_NODE, "give"),
                                mva((Handle)LIST_LINK,
                                    NewNode(CONCEPT_NODE, "ball"),
                                    NewNode(CONCEPT_NODE, "teacher")
                                )
                            )                                       
                        )
            )),
            new SimpleTruthValue(0.01f, getCount(0.01f)),
            new SimpleTruthValue(1.01f, getCount(1.01f)),
            "fetchdemo4.xml",
            10,0);
    maketest(makemeta(mva((Handle)EVALUATION_LINK,
                    NewNode(PREDICATE_NODE, "+++")
            )),
            new SimpleTruthValue(0.01f, getCount(0.01f)),
            new SimpleTruthValue(1.01f, getCount(1.01f)),
            "fetchdemo4.xml",
            10,0);
    maketest(makemeta(mva((Handle)EVALUATION_LINK,
                        NewNode(PREDICATE_NODE, "near"),
                        mva((Handle)LIST_LINK,
                                NewNode(CONCEPT_NODE, "teacher")
                        )
                    )
            ),
            new SimpleTruthValue(0.01f, getCount(0.01f)),
            new SimpleTruthValue(1.01f, getCount(1.01f)),
            "fetchdemo4.xml",
            10,0);
    maketest(makemeta(mva((Handle)IMPLICATION_LINK,
                NewNode(FW_VARIABLE_NODE, "$1"),
                mva((Handle)EVALUATION_LINK,
                    NewNode(PREDICATE_NODE, "+++")
                )
            )),
            new SimpleTruthValue(0.01f, getCount(0.01f)),
            new SimpleTruthValue(1.01f, getCount(1.01f)),
            "fetchdemo4.xml",
            10,0);
*/
/*  maketest(makemeta(mva(
            )),
            new SimpleTruthValue(0.01f, getCount(0.01f)),
            new SimpleTruthValue(1.01f, getCount(1.01f)),
            "fetchdemo4.xml",
            10,0);
    maketest(makemeta(mva(
            )),
            new SimpleTruthValue(0.01f, getCount(0.01f)),
            new SimpleTruthValue(1.01f, getCount(1.01f)),
            "bigdemo.xml",
            10,0);
*/

    INstatsV.push_back(INstats);
}
#endif

// No longer exists!
//bool satSetTest();

//void runPLNTestsOnce();

/*void runPLNTests()
{
//  goal::WalkTest();
//  return;
    
//  satSetTest();

    initPLNTests();

    /// You can run the tests multiple times, which makes sense if
    /// the heuristics function is not deterministic (eg. SoftMax)

    const int TestRepeats = 1;
    int seed = 11111;

    FILE *f = fopen("results.txt","a");

    int tempi=0;

//  for (int tempi = 0; tempi < temperaturesN; tempi++)
    {
        INstatsV.clear();

        temperature = temperatures[tempi];

        for (int t=0; t < TestRepeats; t++)
        {
            //      time_t seconds;
            //      time(&seconds);
            int seconds = 1;
            srand((unsigned int) seconds+(seed++));
            allTestsInferenceNodes = 0;

            runPLNTestsOnce();
            INstatsV[t].push_back(allTestsInferenceNodes);

            if (testFitnessEvaluator != SOFTMAX)
            {
                //No need to play with temperatures or multiple test repeats.
                if (testFitnessEvaluator != RANDOM)
                    t = TestRepeats;
                tempi = temperaturesN;
            }
        }
        INstatsVT.push_back(INstatsV);
    }

    for (uint v=0; v < INstatsV[0].size(); v++)
    {
        fprintf(f, "\n");
        for (int t=0; t < ( (testFitnessEvaluator!=BEST) ? TestRepeats : 1); t++)
            fprintf(f, "%d ", INstatsV[t][v]);
    }

    fclose(f);

    cout << "\n\nTests complete.\n";
}*/

#if 0

#include "Rules.h"
#include "PLNEvaluator.h"
#include "HandleEntry.h"
#include "InferenceMindAgent.h"
#include "Rules.h"
#include "RouletteSelector.h"
#include "BackwardInferenceTask.h"
#include "spacetime.h"

#include <boost/variant/static_visitor.hpp>
#include <boost/scoped_array.hpp>
#include <boost/foreach.hpp>
#include "AtomTable.h"
#include "AtomSpaceWrapper.h"

#include "../core/ClassServer.h"
#include "BackInferenceTree.h"
#include "BackInferenceTreeNode.h"

using namespace opencog::pln;

struct run1
{
    bool echo_process,  echo_result,  target;

    run1(bool _target, bool _echo_process, bool _echo_result)
    : echo_process(_echo_process), echo_result(_echo_result), target(_target)
    {
    }

    bool operator()(tree<Vertex> target1)
    {
        tree<boost::shared_ptr<InferenceNode> > treetrail;
        
        Handle res=0;       
    
        if (echo_result)
        {
            LOG(0,"Proving:");
            rawPrint(target1, target1.begin(),0);
        }

        try {
            if  (res = complexEvaluator->Evaluate(
                    target1.maketree(), treetrail, echo_process))
            {
                if (echo_result)
                {
                    LOG(0, "\nSuccess!\n");
                    rawPrint(res, res.begin(),0);
                    LOG(0, "\n\nIs producible by the chain:\n");
            
//                  for_each<tree<boost::shared_ptr<InferenceNode> >::post_order_iterator, printInferenceNode>
//                      (treetrail.begin_post(), treetrail.end_post(), printInferenceNode());
                }
            }
            else
            {
                if (echo_result)
                    puts("\nFalse. Targetnproducible.\n");
            }
        } catch(InferenceException e) { puts(e.msg.c_str()); }
        catch(...) { puts("UNKNOWN EXCEPTION!!!"); }

        bool result = (res!=NULL);
    
        if (result != target)
        {
            LOG(0, "Unexpected proof result for:");
            rawPrint(target1, target1.begin(),0);
        }

/*      if (echo_result || (result != target))
        {
            char t[20];
            gets(t);
        }*/

        return (result == target);
    }
};

struct Tester : public map<tree<Vertex>, bool>
{
    void run_all(bool echo_process, bool echo_result)
    {
        for (map<tree<Vertex>, bool>::iterator entry = begin(); entry != end(); entry++)
            run1(entry->second, echo_process, echo_result)(entry->first);
    }
    void run_one(tree<Vertex> a, bool target, bool echo_process, bool echo_result)
    {
        run1(target, echo_process, echo_result)(a);
    }
};

void BackwardOsamaProofTest()
{
puts("BackwardOsamaProofTest running...");

//  assert(STLhas(TheNM.LoadedFiles, "bigdemo.xml"));

    Tester tester;
    
    tester  [tree<Vertex>(mva((Handle)EVALUATION_LINK,
                    mva((Handle)PREDICATE_NODE, "friendOf"),
                    mva((Handle)LIST_LINK,
                                mva((Handle)CONCEPT_NODE, "Amir"),
                                mva((Handle)CONCEPT_NODE, "Amir")
                            )
            ))] = false;

    tester  [tree<Vertex>(mva((Handle)EVALUATION_LINK,
                    mva((Handle)PREDICATE_NODE, "wasKilled"),
                    mva((Handle)LIST_LINK,
                                mva((Handle)CONCEPT_NODE, "Osama")
                            )
            ))] = true;

    tester  [tree<Vertex>(mva((Handle)EVALUATION_LINK,
                    mva((Handle)PREDICATE_NODE, "friendOf"),
                    mva((Handle)LIST_LINK,
                                mva((Handle)CONCEPT_NODE, "Amir"),
                                mva((Handle)CONCEPT_NODE, "Osama")
                            )
            ))] = true;
    tester  [tree<Vertex>(mva((Handle)EVALUATION_LINK,
                    mva((Handle)PREDICATE_NODE, "friendOf"),
                    mva((Handle)LIST_LINK,
                                mva((Handle)FW_VARIABLE_NODE, "$OsamaFriend"),
                                mva((Handle)CONCEPT_NODE, "Osama")
                            )
            ))] = true;

    tester  [tree<Vertex>(mva((Handle)EVALUATION_LINK,
                    mva((Handle)PREDICATE_NODE, "friendOf"),
                    mva((Handle)LIST_LINK,
                                mva((Handle)CONCEPT_NODE, "Britney"),
                                mva((Handle)CONCEPT_NODE, "Amir")
                            )
            ))] = true;

    tester  [tree<Vertex>(mva((Handle)INHERITANCE_LINK,
                    mva((Handle)CONCEPT_NODE, "Osama"),
                    mva((Handle)CONCEPT_NODE, "AlQaeda")
            ))] = true;

    tester  [tree<Vertex>(mva((Handle)INHERITANCE_LINK,
                    mva((Handle)CONCEPT_NODE, "AlQaeda"),
                    mva((Handle)CONCEPT_NODE, "terrorist")
            ))] = true;

    tester  [tree<Vertex>(mva((Handle)INHERITANCE_LINK,
                    mva((Handle)CONCEPT_NODE, "Muhammad"),
                    mva((Handle)CONCEPT_NODE, "terrorist")
            ))] = true;

    tester.run_all(false, false);
return;
    for (int _t=0; _t<1; _t++)
    {
        LOG(1, "Run #" + i2str(_t));
        tester.run_one(tree<Vertex>(mva((Handle)EVALUATION_LINK,
                    mva((Handle)PREDICATE_NODE, "friendOf"),
                    mva((Handle)LIST_LINK,
                                mva((Handle)CONCEPT_NODE, "Amir"),
                                mva((Handle)CONCEPT_NODE, "Osama")
                            )
            ), true, true, true);

/*      tester.run_one(tree<Vertex>(mva((Handle)EVALUATION_LINK,
                    mva((Handle)PREDICATE_NODE, "friendOf"),
                    mva((Handle)LIST_LINK,
                                mva((Handle)CONCEPT_NODE, "Amir"),
                                mva((Handle)CONCEPT_NODE, "Amir")
                            )
            ), true, true, true);
*/
/*      tester.run_one(tree<Vertex>(mva((Handle)INHERITANCE_LINK,
//                  mva((Handle)CONCEPT_NODE, "Muhammad"),
                    mva((Handle)CONCEPT_NODE, "AlQaeda"),
                    mva((Handle)CONCEPT_NODE, "terrorist") //"Osama")
            ), true, true, true);
*/
/*      tester.run_one(tree<Vertex>(mva((Handle)EVALUATION_LINK,
                    mva((Handle)PREDICATE_NODE, "friendOf"),
                    mva((Handle)LIST_LINK,
                                mva((Handle)CONCEPT_NODE, "Britney"),
                                mva((Handle)CONCEPT_NODE, "Amir")
                            )
            ), true, true, true);*/

/*      tester.run_one(tree<Vertex>(mva((Handle)INHERITANCE_LINK,
                    mva((Handle)CONCEPT_NODE, "Britney"),
                    mva((Handle)CONCEPT_NODE, "terrorist")
            ), true, true, true);*/

/*  tester.run_one(tree<Vertex>(mva((Handle)EVALUATION_LINK,
                    atom(PREDICATE_NODE, "wasKilled"),
                    atom(LIST_LINK,
                                atom(CONCEPT_NODE, "Osama")
                            )
            ), true, false, true);*/


//  printf("\nUnprovable atoms: %d\n", opencog::pln::haxx::Unprovable().size());
//  printf("\nProvable atoms: %d\n", opencog::pln::haxx::Provable().size());

        printf("\nReserved atoms: %d\n", atom_alloc_count);
        printf("\nReserved InferenceNodes: %d\n", inode_alloc_count);

        freehaxx();

        puts("After killing the haxx tree");
        printf("\nReserved atoms: %d\n", atom_alloc_count);
        printf("\nReserved InferenceNodes: %d\n", inode_alloc_count);
    }
}

void SetProofTest();
void BOATest();
void ForwardOsamaProofTest();
void BackwardOsamaProofTest();
void RelimTest();
void FIMTest();
void NewChainerTest();

int __ptlc=0;

namespace opencog { namespace pln {
Handle Ass(iAtomSpaceWrapper *destTable, Handle h, std::vector<Handle>& ret);
}};

//void TestAssociatedSets()
{
/*    Testing associated sets*/
    
/*      AtomSpaceWrapper& TheNM = *((AtomSpaceWrapper*)ASW());
    
      Handle h1 = Ass(&TheNM, atom(CONCEPT_NODE, "terrorist").attach(ASW()), testv);
      Handle h2 = Ass(&TheNM, atom(CONCEPT_NODE, "Muhammad").attach(ASW()), testv);
      Handle hs[] = {h1,h2};

      SubsetEvalRule ser(&TheNM);
      Handle IntInhSet = ser.compute(hs,2);

      printTree(IntInhSet,0,1);*/
}

void InferenceTests()
{
    try {   
      map<string,Handle> bindings;

/*          Handle t5 = atom(IMPLICATION_LINK, 2, 
                    new atom(AND_LINK, 2,
                        new atom(SUBSET_LINK, 2,
                            new atom(CONCEPT_NODE, "D"),
                            new atom(CONCEPT_NODE, "Z")
                        ),
                        new atom(EVALUATION_LINK, 2, 
                            new atom(PREDICATE_NODE, "union"),
                            new atom(LIST_LINK, 3,
                                new atom(CONCEPT_NODE, "W"),
                                new atom(CONCEPT_NODE, "C"),
                                new atom(FW_VARIABLE_NODE, "$1")
                            )
                        )
                    ),
                    new atom(SUBSET_LINK, 2,
                        new atom(FW_VARIABLE_NODE, "$2"),
                        new atom(CONCEPT_NODE, "Z")
                    )
                ).attach(((AtomSpaceWrapper*)ASW()));
*/
/*  Handle t0 = atom(IMPLICATION_LINK, 2, 
                    new atom(AND_LINK, 2,
                        new atom(SUBSET_LINK, 2,
                            new atom(CONCEPT_NODE, "D"),
                            new atom(CONCEPT_NODE, "Z")
                        ),
                        new atom(EVALUATION_LINK, 2, 
                            new atom(PREDICATE_NODE, "union"),
                            new atom(LIST_LINK, 3,
                                new atom(CONCEPT_NODE, "Q"),
                                new atom(CONCEPT_NODE, "C"),
                                new atom(FW_VARIABLE_NODE, "$1")
                            )
                        )
                    ),
                    new atom(SUBSET_LINK, 2,
                        new atom(FW_VARIABLE_NODE, "$2"),
                        new atom(CONCEPT_NODE, "Z")
                    )
                ).attach(((AtomSpaceWrapper*)ASW()));
        
    Handle t1 = atom(IMPLICATION_LINK, 2, 
                    new atom(AND_LINK, 2,
                        new atom(SUBSET_LINK, 2,
                            new atom(CONCEPT_NODE, "D"),
                            new atom(CONCEPT_NODE, "Z")
                        ),
                        new atom(EVALUATION_LINK, 2, 
                            new atom(PREDICATE_NODE, "union"),
                            new atom(LIST_LINK, 3,
                                new atom(CONCEPT_NODE, "Q"),
                                new atom(CONCEPT_NODE, "C"),
                                new atom(CONCEPT_NODE, "Z")
                            )
                        )
                    ),
                    new atom(SUBSET_LINK, 2,
                        new atom(CONCEPT_NODE, "D"),
                        new atom(CONCEPT_NODE, "Z")
                    )
                ).attach(((AtomSpaceWrapper*)ASW()));
        Handle t2 = t1;
      
//  bool s1 = substitutableTo(t1, t2, bindings);
//  bool s5 = substitutableTo(t5, t2, bindings);

LOG(0,"\n-------\n");
    
    bool s0 = substitutableTo(t0, t2, bindings);
    */
    //if (s1) puts("True!");
    //else puts("0!"); 
    /*if (s5) puts("True!");
    else puts("0!"); */
/*  if (s0) puts("True!");
    else puts("0!");    */
  } catch(std::string s)
  {
      LOG(0, s + " at root level.");
  }
  catch(...)
  {
      LOG(0, "Unknown exception at root level. ");
  }
}

void GeneralTests()
{
/*  LOG(2, "Dumping Core...");
    
     TheNM.DumpCoreLinks(1);*/
/*
puts("Osama:terrorist");
      TableGather fa(atom(INHERITANCE_LINK, 2,
                    new atom(CONCEPT_NODE, "Osama"),
                    new atom(CONCEPT_NODE, "terrorist") //"Osama")
            ));

      for_each<std::vector<Handle>::iterator, handle_print<0> >(fa.begin(), fa.end(), handle_print<0>());

atom(INHERITANCE_LINK, 2,
                                new atom(CONCEPT_NODE, "Osama"),
                                new atom(CONCEPT_NODE, "Amir")
            ).attach(ASW());
      for_each<std::vector<Handle>::iterator, handle_print<0> >(fa.begin(), fa.end(), handle_print<0>());
    */
/*puts("LL2:");         
      TableGather LL(atom(LIST_LINK, 2,
                                new atom(CONCEPT_NODE, "Amir"),
                                new atom(CONCEPT_NODE, "Amir")
            ));
      for_each<std::vector<Handle>::iterator, handle_print<0> >(LL.begin(), LL.end(), handle_print<0>());
puts(":");

    atom(CONCEPT_NODE, "Gibson").attach(ASW());
    Node *node = new Node(CONCEPT_NODE, strdup("Gibson"));
    MindDBProxy::getInstance()->add(node, true);
    printTree(ASW()->getHandle(CONCEPT_NODE, "Gibson"),0,0);
      TableGather gg(atom(CONCEPT_NODE, "Gibson"));
      for_each<std::vector<Handle>::iterator, handle_print<0> >(gg.begin(), gg.end(), handle_print<0>());
getc(stdin);*/

//  BackwardOsamaProofTest();

      //TheNM.DumpCore(FORALL_LINK);

/* // Dump universally-quantified expressions:
      TableGather fa(atom(__INSTANCEOF_N,1,
                            new atom(FORALL_LINK,0)
                    ));
      for_each<TableGather::iterator, handle_print<0> >(fa.begin(), fa.end(), handle_print<0>());*/

//    BOATest();
//    ForwardOsamaProofTest();

/*  HandleEntry* result = MindDBProxy::getInstance()->getHandleSet((Type)INHERITANCE_LINK, true);
            printf("%d results direct\n", result->getSize());*/

    //FIMTest();

//  NewChainerTest();
}

void AgentTest2()
{
    using namespace opencog::pln;
    
    initAxiomSet("fetch.xml");
#if 1
    set<MindAgent*> agents;
    AtomSpaceWrapper& TheNM = *((AtomSpaceWrapper*)ASW());

    vtree rewardt(mva((Handle)EVALUATION_LINK,
                NewNode(PREDICATE_NODE, "+++")));
    Handle reward = NewAtom(rewardt);

    /// the addAtom interface needs improvement!
    vtree mediatort(mva((Handle)EVALUATION_LINK, NewNode(PREDICATE_NODE,"mediator")));
//  vtree walkt(mva((Handle)EXECUTION_LINK, NewNode(PREDICATE_NODE,"move.forward"), NewNode(NUMBER_NODE, "2.0")));
//  vtree walkbackt(mva((Handle)EXECUTION_LINK, NewNode(PREDICATE_NODE,"move.backward"), NewNode(NUMBER_NODE, "2.0")));
    vtree walkt(mva((Handle)EVALUATION_LINK,
                        //NewNode(PREDICATE_NODE,"just_done"),
                        NewNode(PREDICATE_NODE,"do"),
                        mva((Handle)LIST_LINK,
                            mva((Handle)EXECUTION_LINK, NewNode(PREDICATE_NODE,"move.forward 2.0")))
                ));
    vtree walkbackt(mva((Handle)EVALUATION_LINK,
                        NewNode(PREDICATE_NODE,"do"),
//                      NewNode(PREDICATE_NODE,"just_done"),
                        mva((Handle)LIST_LINK,
                            mva((Handle)EXECUTION_LINK, NewNode(PREDICATE_NODE,"move.backward 2.0")))
                    ));
    vtree runt(mva((Handle)EXECUTION_LINK, NewNode(PREDICATE_NODE,"move.forward 0.1")));
    Handle mediator = NewAtom(mediatort);
//  Handle walk     = NewAtom(walkt);
    Handle walk_back= TheNM.addAtom(
            walkbackt,
            new SimpleTruthValue(0.5,0.5), true, false);
    Handle walk = TheNM.addAtom(
            walkt,
            new SimpleTruthValue(0.5,0.5), true, false);
    //NewAtom(walkbackt);
    Handle run = NewAtom(runt);

/*  vtree walk_to_reward(mva((Handle)IMP,
                mva(walk),
                mva(reward)));
    vtree run_tp_mediate(mva((Handle)IMP,
                mva(run),
                mva(mediator)));
    vtree mediate_to_reward(mva((Handle)IMP,
                mva(mediator),
                mva(reward)));
        
    printTree(TheNM.addAtom(
i           walk_to_reward,
            new SimpleTruthValue(0.2,0.2), true, false), 0,-3);*/
/*
    printTree(TheNM.addAtom(
            run_tp_mediate,
            new SimpleTruthValue(0.1,0.9), true, false), 0,-3);
    
    printTree(TheNM.addAtom(
            mediate_to_reward,
            new SimpleTruthValue(0.1,0.9), true, false), 0,-3);
*/

#ifndef WIN32
    /*  timeval currentTime;
    gettimeofday(&currentTime, NULL);
    long now_stamp = currentTime.tv_sec*1000 + currentTime.tv_usec/1000;*/
    long now_stamp = getElapsedMillis();
    long now_interval = 1000;
#else
    long now_stamp = 3000;
    long now_interval = 1000;
#endif
    char end_stamp_s[100], begin_stamp_s[100];
    sprintf(begin_stamp_s, "%ul", now_stamp-now_interval);
    sprintf(end_stamp_s, "%ul", now_stamp);

    char startNodeName[100], endNodeName[100];
    sprintf(startNodeName, "%ul", 0);
    sprintf(endNodeName, "%ul", 1000000);

    /**
Timestamps denote the number of milliseconds since (00:00:00 UTC, January
1, 1970), which is the Epoch used by time_t time(time_t *t) C function.
See the manual for it by typing "man 2 time" in your Linux prompt.
*/

            vtree heard_sound(
                mva((Handle)EVALUATION_LINK,
                    NewNode(PREDICATE_NODE, "atInterval"),
                    mva((Handle)LIST_LINK,
                    mva((Handle)EVALUATION_LINK,
                        NewNode(PREDICATE_NODE, "AGISIM_quality"),
                        mva((Handle)LIST_LINK,
                            NewNode(AGISIM_SOUND_NODE, ""),
                            NewNode(NUMBER_NODE, "1000")
                            )
                        ),
                    NewNode(NUMBER_NODE, startNodeName),
//                  NewNode(NUMBER_NODE, endNodeName),                  
//                  NewNode(CONCEPT_NODE, "!whileago"),
                    NewNode(CONCEPT_NODE, "!now")
                    )
                ));
                
    vtree back_when_sound(mva((Handle)IMP,
            mva((Handle)AND_LINK,
                heard_sound,
                mva(walk_back)),
            mva(reward)));

    vtree target(mva((Handle)EVALUATION_LINK,
            NewNode(PREDICATE_NODE, "+++")));

/*  
    vtree forward_when_no_sound(mva((Handle)IMP,
            mva((Handle)AND_LINK,
                mva((Handle)NOT_LINK,
                    heard_sound),
                mva(walk_back)),
            mva(reward)));
    
    printTree(TheNM.addAtom(
        forward_when_no_sound,
        new SimpleTruthValue(0.95,0.95), true, false)
    ,0,-3);
*/
    printTree(TheNM.addAtom(
        back_when_sound,
        new SimpleTruthValue(0.95,0.95), true, false)
    ,0,-3);

    //  puts("start agents");
    //  while (1)
    //  for_each(agents.begin(), agents.end(), mem_fun(&MindAgent::execute));
#endif
}

#endif
