/*
 * BackwardChainerUTest.cxxtest
 *
 *  Created on: Oct 20, 2014
 *      Author: misgana
 */
#include <opencog/reasoning/RuleEngine/rule-engine-src/pln/BackwardChainer.h>
#include <opencog/guile/SchemeEval.h>
#include <opencog/guile/SchemeSmob.h>
#include <opencog/atomspace/AtomSpace.h>
#include <opencog/server/CogServer.h>
#include <opencog/util/Config.h>
#include <opencog/guile/load-file.h>

using namespace opencog;
//#define DEBUG 1
class BackwardChainerUTest: public CxxTest::TestSuite {
private:
	AtomSpace *as_;
	SchemeEval* eval_;
	BackwardChainer * bc_;
public:
	BackwardChainerUTest() {
		server(CogServer::createInstance);
		as_ = &cogserver().getAtomSpace();
		eval_ = new SchemeEval(as_);
		bc_ = new BackwardChainer(as_, {});

		cogserver().loadModules();
		cogserver().loadSCMModules();
		config().set("MODULES", "opencog/query/libQueryModule.so");

	}
	~BackwardChainerUTest() {
		delete bc_;
		delete eval_;
	}
	void setUp();
	void tearDown();

	void test_filter_rules();
	void test_unify();
	void test_simple_deduction_bc();
	// void test_do_bc();
};

void BackwardChainerUTest::setUp() {
	config().set("SCM_PRELOAD",
	             "opencog/atomspace/core_types.scm, "
	             "opencog/scm/utilities.scm, "
	             "opencog/python/pln/examples/backward_chaining/criminal.scm, "
	             "tests/reasoning/RuleEngine/bc-test/bc-example.scm");
	load_scm_files_from_config(*as_);
}

void BackwardChainerUTest::tearDown() {
	as_->clear();
}

void BackwardChainerUTest::test_filter_rules() {
	string bl1 =
		"(BindLink"		
		"    (VariableList"
		"        (VariableNode \"$A\") (VariableNode \"$B\"))"
		"    (ImplicationLink"
		"        (AndLink"
		"            (ImplicationLink"
        "                (VariableNode \"$A\")"
		"                (VariableNode \"$B\")))"
		"        (ListLink"
		"            (ExecutionLink"
		"                (GroundedSchemaNode \"scm: pln-formula-simple-modus-ponens\")"
		"                (ListLink"
		"                    (ImplicationLink"
		"		                 (VariableNode \"$A\")"
		"                        (VariableNode \"$B\")))))))";
	Handle hb1 = eval_->eval_h(bl1);

	string bl2 =
		"(ImplicationLink (stv .99 .99)"
		"    (AndLink"
		"        (InheritanceLink"
		"            (VariableNode \"$x\")"
		"            (ConceptNode \"American\"))"
		"        (InheritanceLink"
		"            (VariableNode \"$y\")"
		"            (ConceptNode \"weapon\"))"
		"        (EvaluationLink"
		"            (PredicateNode \"sell\")"
		"            (ListLink"
		"                (VariableNode \"$x\")"
		"                (VariableNode \"$y\")"
		"                (VariableNode \"$z\")))"
		"        (InheritanceLink"
		"            (VariableNode \"$z\")"
		"            (ConceptNode \"hostile\")))"
		"    (InheritanceLink"
		"        (VariableNode \"$x\")"
		"        (ConceptNode \"criminal\")))";
	Handle hb2 = eval_->eval_h(bl2);

	Handle hb1_il =
		eval_->eval_h("(ImplicationLink"
		              "    (VariableNode \"$A\")"
		              "    (VariableNode \"$B\"))");

	Handle hb2_il =
		eval_->eval_h("(InheritanceLink"
		              "    (VariableNode \"$x\")"
		              "    (ConceptNode \"criminal\"))");

	// HandleSeq hsresult = { hb1_il, hb2_il };
	// HandleSeq hsrules = bc_->filter_rules(hsresult);
	// TODO look at the result itself, not just the size!!!
	// TS_ASSERT_EQUALS(hsrules.size(), 1);
}

void BackwardChainerUTest::test_unify() {
	string target =
		"(EvaluationLink"
		"    (PredicateNode \"sell\")"
		"    (ListLink"
		"        (VariableNode \"$x\")"
		"        (VariableNode \"$y\")"
		"        (VariableNode \"$z\")))";
	Handle htarget = eval_->eval_h(target);

	string match =
		"(EvaluationLink"
		"    (PredicateNode \"sell\")"
		"    (ListLink"
		"        (ConceptNode \"west\")"
		"        (VariableNode \"$a\")"
		"        (ConceptNode \"nono\")))";

	Handle hmatch = eval_->eval_h(match);
	VarMap result;
	bc_->unify(htarget, hmatch, result);
	// Look at the result itself not just the size!!!
	TS_ASSERT_EQUALS(result.size(), 3);
}

void BackwardChainerUTest::test_simple_deduction_bc() {
	// Test simple deduction
	//
	// InheritanceLink A B
	// InheritanceLink B C
	// |-
	// InheritanceLink A C
	Handle A = eval_->eval_h("(ConceptNode \"A\" (stv 0.2 0.9))"),
		B = eval_->eval_h("(ConceptNode \"B\" (stv 0.3 0.9))"),
		C = eval_->eval_h("(ConceptNode \"C\" (stv 0.1 0.9))"),
		AB = eval_->eval_h("(InheritanceLink (stv 0.9 0.9)"
		                   "    (ConceptNode \"A\")"
		                   "    (ConceptNode \"B\"))"),
		BC = eval_->eval_h("(InheritanceLink (stv 0.8 0.9)"
		                   "    (ConceptNode \"B\")"
		                   "    (ConceptNode \"C\"))"),
		// The TV is missing cause it's the target
		AC = eval_->eval_h("(InheritanceLink"
		                   "    (ConceptNode \"A\")"
		                   "    (ConceptNode \"C\"))");

	map<Handle, HandleSeq> result; // = bc_->do_bc(AC);
	std::cout << "result:" << std::endl;
	for (const auto& element : result) {
		std::cout << "Key = " << element.first->toString() << std::endl;
		std::cout << "{" << std::endl;
		for (const auto& value : element.second)
			std::cout << "  Value = " << value->toString() << std::endl;
		std::cout << "}" << std::endl;		
	}

	// TODO: maybe check that the result is AC and that its confidence
	// is above 0
	TS_ASSERT(false);
}


// void BackwardChainerUTest::test_do_bc() {
// 	Handle htarget =
// 		eval_->eval_h("(InheritanceLink (VariableNode \"$isCriminal\")"
// 		              "                 (ConceptNode \"criminal\"))");
// 	Handle htarget2 =
// 		eval_->eval_h("(EvaluationLink"
// 		              "    (PredicateNode \"sell\")"
// 		              "    (ListLink"
// 		              "        (ConceptNode \"West\")"
// 		              "        (VariableNode \"$a\")"
// 		              "        (ConceptNode \"Nono\")))");
// 	Handle htarget3 =
// 		eval_->eval_h("(EvaluationLink"
// 		              "    (PredicateNode \"sell\")"
// 		              "    (ListLink"
// 		              "        (VariableNode \"$x\")"
// 		              "        (VariableNode \"$y\")"
// 		              "        (VariableNode \"$z\")))");
// 	Handle htarget4 =
// 		eval_->eval_h("(InheritanceLink (VariableNode \"$isAmerican\")"
// 		              "                 (ConceptNode \"American\"))");
// 	Handle htarget5 =
// 		eval_->eval_h("(InheritanceLink (VariableNode \"$whosFrog\")"
// 		              "                 (ConceptNode \"Frog\"))");
// 	Handle htarget6 =
// 		eval_->eval_h("(InheritanceLink (VariableNode \"$whosGreen\")"
// 		              "                 (ConceptNode \"green\"))");
// 	Handle htarget7 =
// 		eval_->eval_h("(InheritanceLink (VariableNode \"$whosCanary\")"
// 		              "                 (ConceptNode \"Canary\"))");

// 	std::cout << "Atomspace = " << *as_;
	
// 	map<Handle, HandleSeq> result = bc_->do_bc(htarget);
// 	TS_ASSERT_EQUALS(result.size(), 1);
// 	auto it = result.begin();
// 	TS_ASSERT_EQUALS(it->second.size(), 1);
// 	TS_ASSERT_EQUALS(it->second[0].value(),
// 			eval_->eval_h("(ConceptNode \"West\")").value());

// 	result = bc_->do_bc(htarget6);
// 	TS_ASSERT_EQUALS(result.size(), 1);
// 	it = result.begin();
// 	TS_ASSERT_EQUALS(it->second.size(), 1);
// 	TS_ASSERT_EQUALS(it->second[0].value(),
// 			eval_->eval_h("(ConceptNode \"Fritz\")").value());

// 	result = bc_->do_bc(htarget5);
// 	TS_ASSERT_EQUALS(result.size(), 1);
// 	it = result.begin();
// 	TS_ASSERT_EQUALS(it->second.size(), 1);
// 	TS_ASSERT_EQUALS(it->second[0].value(),
// 			eval_->eval_h("(ConceptNode \"Fritz\")").value());

// 	result = bc_->do_bc(htarget7);
// 	TS_ASSERT_EQUALS(result.size(), 1);
// 	it = result.begin();
// 	TS_ASSERT_EQUALS(it->second.size(), 0);

// 	result = bc_->do_bc(htarget4);
// 	TS_ASSERT_EQUALS(result.size(), 1);
// 	it = result.begin();
// 	TS_ASSERT_EQUALS(it->second.size(), 1);
// 	TS_ASSERT_EQUALS(it->second[0].value(),
// 			eval_->eval_h("(ConceptNode \"West\")").value());

// 	result = bc_->do_bc(htarget3);
// 	TS_ASSERT_EQUALS(result.size(), 3);
// 	it = result.begin();
// 	TS_ASSERT_EQUALS(it->second.size(), 1);
// 	TS_ASSERT_EQUALS(it->second[0].value(),
// 			eval_->eval_h("(ConceptNode \"West\")").value());
// 	++it;
// 	TS_ASSERT_EQUALS(it->second.size(), 1);
// 	TS_ASSERT_EQUALS(it->second[0].value(),
// 			eval_->eval_h("(ConceptNode \"missile@123\")").value());
// 	++it;
// 	TS_ASSERT_EQUALS(it->second.size(), 1);
// 	TS_ASSERT_EQUALS(it->second[0].value(),
// 			eval_->eval_h("(ConceptNode \"Nono\")").value());

// 	result = bc_->do_bc(htarget2);
// 	TS_ASSERT_EQUALS(result.size(), 1);
// 	it = result.begin();
// 	TS_ASSERT_EQUALS(it->second.size(), 1);
// 	TS_ASSERT_EQUALS(it->second[0].value(),
// 			eval_->eval_h("(ConceptNode \"missile@123\")").value());

// 	/*if (result.empty())
// 	 cout << "EMPTY RESULT RETURNED" << endl;
// 	 cout << "RESULT RETURNED" << endl;
// 	 for (auto it = result.begin(); it != result.end(); ++it) {
// 	 cout << endl << "VAR:" << SchemeSmob::to_string(it->first) << endl;
// 	 HandleSeq values = it->second;
// 	 for (Handle h : values)
// 	 cout << "\t\tVALUE:" << SchemeSmob::to_string(h) << endl;
// 	 }*/

// }
