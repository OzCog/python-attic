/*
 * tests/atomspace/UseCountUTest.cxxtest
 *
 * Copyright (C) 2013, 2014 Linas Vepstas <linasvepstas@gmail.com>
 * All Rights Reserved
 *
 * Written by Linas Vepstas <linasvepstas@gmail.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License v3 as
 * published by the Free Software Foundation and including the exceptions
 * at http://opencog.org/wiki/Licenses
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program; if not, write to:
 * Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <algorithm>
#include <atomic>
#include <thread>

#include <math.h>
#include <string.h>

#include <opencog/atomspace/AtomSpace.h>
#include <opencog/util/Logger.h>
#include <opencog/util/platform.h>
#include <opencog/util/Config.h>

#include "misc-test.h"

using namespace opencog;
using namespace std;

class UseCountUTest :  public CxxTest::TestSuite
{
private:

    AtomSpace *atomSpace;
    Handle anchor;

    // Counters must be atomic; we are incrementing them inside threads
    std::atomic_int __totalAdded;
    std::atomic_int __finished;

    int n_threads;
    int n_removal_threads;
    int num_atoms;
    bool spinwait;
    std::vector<int> rm_cnt;

public:
    UseCountUTest()
    {
        // Current atomspace can to 50K or 100K atoms/sec, so the
        // below should run for at least 2 to 5 seconds each time.
        n_threads = 20;
        n_removal_threads = 3;
        rm_cnt.resize(n_removal_threads, 0);
        num_atoms = 13000;
        logger().setLevel(Logger::INFO);
        logger().setPrintToStdoutFlag(true);
    }

    void setUp()
    {
        atomSpace = new AtomSpace();
    }

    void tearDown()
    {
        delete atomSpace;
    }

    // =================================================================

    void threadedLinkAdd(int thread_id, int N)
    {
        // Create Lots of the following structures:
        //
        //    ListLink
        //        AnchorNode "the anchor"
        //        ConceptNode "some value"
        //
        for (int i = 0; i < N; i++) {
            std::ostringstream oss;
            oss << "thread " << thread_id << " node " << i;

            Handle n = atomSpace->addNode(CONCEPT_NODE, oss.str());

            Type t = LIST_LINK;
            atomSpace->addLink(t, anchor, n);
            __totalAdded += 2;
        }
        __finished ++;
    }

    void threadedLinkRemove(int thread_id)
    {
        // Remove all of the following structures, leaving behind
        // only the anchor:
        //
        //    ListLink
        //        AnchorNode "the anchor"
        //        ConceptNode "some value"
        //

        while (true)
        {
            IncomingSet iset = anchor->getIncomingSet();
            size_t isz = iset.size();
            for (size_t i = 0; i < isz; i++) {
                Handle n = iset[i]->getOutgoingAtom(1);

                atomSpace->removeAtom(n);
                atomSpace->removeAtom(Handle(iset[i]));
                rm_cnt[thread_id] += 2;
                __totalAdded -= 2;
            }
            if (0 == isz and __finished >= n_threads) break;
        }
    }

    void testUseCount()
    {
        // reset the counts
        __totalAdded = 0;
        __finished = 0;

        anchor = atomSpace->addNode(ANCHOR_NODE, "*** The Anchor ***");
        __totalAdded++;
        long int initial_use_count = AtomPtr(anchor).use_count();
        std::cout << "Initial anchor use count=" << initial_use_count << std::endl;
        size_t isize = atomSpace->getSize();
        std::cout << "Initial atomspace size: " << isize << std::endl;

        // Add lotsa links
        std::vector<std::thread> thread_pool;
        for (int i=0; i < n_threads; i++) {
            thread_pool.push_back(
                std::thread(&UseCountUTest::threadedLinkAdd, this, i, num_atoms));
        }

        // Remove lotsa links, using only 3 threads
        for (int i=0; i < n_removal_threads; i++) {
            thread_pool.push_back(
                std::thread(&UseCountUTest::threadedLinkRemove, this, i));
        }

        // Wait for it all to come together.
        for (std::thread& t : thread_pool) t.join();

        long int final_use_count = AtomPtr(anchor).use_count();
        std::cout << "Final anchor use count=" << final_use_count << std::endl;
        size_t fsize = atomSpace->getSize();
        std::cout << "Final atomspace size: " << fsize << std::endl;
        std::cout << "Total change: " << __totalAdded << std::endl;

        int rmtot = 0;
        for (int i=0; i < n_removal_threads; i++) {
            std::cout << "Thread " << i << " removed:" << rm_cnt[i] << std::endl;
            rmtot += rm_cnt[i];
        }
        std::cout << "Total removed:" << rmtot << std::endl;

        // We should get only 1 atom, the anchor node itself
        TS_ASSERT_EQUALS(isize, 1);
        TS_ASSERT_EQUALS(fsize, 1);

        TS_ASSERT_EQUALS((int) __totalAdded, num_atoms);
    }

    // =================================================================
};
