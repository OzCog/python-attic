// OpenCog graph visualiser
// Copyright 2010 Joel Pitt

//Node nodes[];
//Link links[];
//int cur_nodes = 0; max_nodes = 100;
//int cur_links = 0; max_links = 500;
int current_atom;
float kinetic_energy = 0.1; /* just some value above threshold to begin */
float kinetic_threshold = 0.02;
float timestep = 1.0;
float damping = 0.95;
var nodes = new Array();
var links = new Array();
boolean ready = false;

int selected=-1;

void lnPrinted(){
    console.log( ln );
}

void add_link(data,textStatus,XMLHttpRequest,depth) {
    
    if (depth > 2) return;
    // link
    // add outgoing links
    console.log( "Loading link " + data.handle );
    links[data.handle] = new Link(data);
    for (var i = 0;i<data.outgoing.length;i++)
    {
        node_uuid = data.outgoing[i];
        if (!(node_uuid in nodes)) {
            $.ajax({url:"/rest/0.2/atom/"+data.outgoing[i],
                dataType:"json",success:add_node});
            //nodes[node_uuid] = new Node(node_uuid);

        }
    }
    kinetic_energy = kinetic_threshold+1;
}

void add_node(data,textStatus,XMLHttpRequest,depth) {
    if (depth > 2) return;
    nodes[data.handle] = new Node(data.handle);
    for (var i = 0;i<data.incoming.length;i++)
    {
        link_uuid = data.incoming[i];
        if (!(link_uuid in links)) {
            $.ajax({url:"/rest/0.2/atom/"+data.incoming[i],
                dataType:"json",success:add_link});
        }
    }

}

void add_root(data,textStatus,XMLHttpRequest) {
    console.log( "Loading focus " + data.handle );
    // Handle adding root node and retrieving incoming/outgoing links
    if (data.outgoing.length > 0) {
        add_link(data,textStatus,XMLHttpRequest,0);
    } else {
        add_node(data,textStatus,XMLHttpRequest,0);
        nodes[data.handle].x = width/2;
        nodes[data.handle].y = height/2;
        nodes[data.handle].pinned = true;
        nodes[data.handle].mass = 4;

    }
    current_atom=data.handle;
    ready = true;
    kinetic_energy = kinetic_threshold+1;
}

void setup() {
  size(400, 400);
  //nodes = new Node[max_nodes];
  //links = new Link[max_links];
  //random_graph(20,0.5);
  PFont fontA = loadFont("Arial");
  textFont(fontA, 16);
  $.ajax({url:"/rest/0.2/atom/"+handle,
    dataType:"json",success:add_root});

}

void random_graph(int N, float connectedness) {
  if (N > max_links) N = max_links;
  for (int i=0; i < N ; i++) {
      nodes[i] = new Node(i);
      nodes[i].mass = random(1,3);
  }
  //cur_nodes = N;
  int n_links = N*connectedness;
  for (int i=0; i < n_links && i < max_links; i++)
  {
      Node n1,n2;
      n1 = nodes[(int)random(N)];
      n2 = n1;
      while (n2 == n1) {
	  n2 = nodes[(int)random(N)];
      }
      links[i] = new Link(n1,n2);
  }
  //cur_links = n_links;
}

void draw() {
  background(#555555);
  if (!ready) return;
  if (kinetic_energy > kinetic_threshold || selected >= 0 ) {
      update();
      //println(kinetic_energy);
  }
  for (var i in links)
  {
     line(links[i].outgoing[0].x,links[i].outgoing[0].y,
	links[i].outgoing[1].x,links[i].outgoing[1].y);
  }

  for (var i in nodes)
  {
      n = nodes[i];
      if (n.pinned) {
	  fill(255,0,0);
	  ellipse(n.x, n.y, n.mass*5,n.mass*5);
      } else {
	  fill(255);
	  ellipse(n.x, n.y, n.mass*5,n.mass*5);
      }
  }
  fill(255);
  text("Pin and drag nodes with left click",10,height-18);

}

void mousePressed() {
    nearest = -1;
    nearest_dist = width*height;
    /* find nearest node */
    for (var i in nodes)
    {
        dx = nodes[i].x - mouseX;
        dy = nodes[i].y - mouseY;
        dist = sqrt(dx*dx + dy*dy);
        if (dist < nearest_dist) {
            nearest_dist = dist;
            nearest = i;
        }
    }
    /* radius * 1.5 */
    if (nearest_dist < nodes[nearest].mass*5) {
        selected = nearest;
        nodes[selected].x = mouseX;
        nodes[selected].y = mouseY;
        //println ("selected node: " + nodes[nearest].handle);
    }
    drag_time = 0;
}

void mouseReleased() {
    if (selected != -1 && drag_time < 5) {
	nodes[selected].pinned=!nodes[selected].pinned;
    }
    selected = -1;
    kinetic_energy = kinetic_threshold+1;
}

void mouseDragged() {
    /* if mouse pressed then fix mouseX */
    if (selected >= 0) {
        nodes[selected].x = mouseX;
        nodes[selected].y = mouseY;
    }
    drag_time += 1;
    kinetic_energy = kinetic_threshold+1;
}

float repulsion(Node n1, Node n2) {
    repulse = 0.04 * (n1.mass + n2.mass);
    dx = (n1.x - n2.x);
    dy = (n1.y - n2.y);
    dist = sqrt(dx*dx + dy*dy);
    float[] r = { repulse * (1.0 / dx),repulse * (1.0 / dy)};
    return r
}

float attraction(Node n, Link l) {
    attract = 1.5;
    n1 = l.outgoing[0]; n2 = l.outgoing[1];
    dx = (n1.x - n2.x) / width;
    dy = (n1.y - n2.y) / height;
    dist = sqrt(dx*dx + dy*dy);
    inverse=-1;
    if (n2 == n) { inverse=1; }
    float[] a = {inverse * attract * (dx*dx),inverse * attract * (dy*dy)};
    /* squaring removes the sign, so restore it */
    if (dx < 0.0) a[0] = -a[0];
    if (dy < 0.0) a[1] = -a[1];
    return a;
}

float spring(Node n, Link l) {
    float attract = .05;
    n1 = l.outgoing[0]; n2 = l.outgoing[1];
    float ideal_dist = n1.mass * 10 + n2.mass * 10;
    dx = (n1.x - n2.x);
    dy = (n1.y - n2.y);
    dist = sqrt(dx*dx + dy*dy);
    diff = dist - ideal_dist;
    angle = atan2(dy,dx);
    dx = diff * cos(angle);
    dy = diff * sin(angle);
    if (n2 != n) { dx = -dx; dy = -dy; }
    float[] a = {attract * dx,attract * dy};
    //println ("spring: " + a[0] + " " + a[1]);
    /* squaring removes the sign, so restore it */
    //if (dx < 0.0) a[0] = -a[0];
    //if (dy < 0.0) a[1] = -a[1];
    return a;
}

void update() {
    /* do force directed layout */
    kinetic_energy = 0.0;
    for (var i in nodes) {
        n = nodes[i];
        if (selected == i || n.pinned) continue;
        net_force = [ 0.0, 0.0 ];
        /* Electro static repulsion */
        for (var j in nodes) {
            if(j == i) continue;
            r = repulsion(n,nodes[j]);
            net_force[0] += r[0];
            net_force[1] += r[1];
        }
        /* Spring ideal length */
        for (var j in links) {
            l = links[j];
            if (l.outgoing[0] == n || l.outgoing[1] == n) {
            //a = attraction(n, l);
            a = spring(n, l);
            net_force[0] += a[0];
            net_force[1] += a[1];
            }
        }
        /* limit maximum force applied */
        net_force[0] = constrain(net_force[0],-3,3);
        net_force[1] = constrain(net_force[1],-3,3);
        /* prevent leaving view */
        if (n.x > width) {
            net_force[0] = -0.1;
        }
        if (n.x < 0) {
            net_force[0] = 0.1;
        }
        if (n.y > height) {
            net_force[1] = -0.1;
        }
        if (n.y < 0) {
            net_force[1] = 0.1;
        }
        /* change velocity */
        n.vx = (n.vx + (timestep * net_force[0])) * damping;
        n.vy = (n.vy + (timestep * net_force[1])) * damping;
        /*float v = sqrt(n.vx*n.vx + n.vy*n.vy);
        if (v > 5) {
            println ("large velocity: " + i + " v=" + v);
        }*/
        /* update position */
        n.x += (timestep * n.vx);
        n.y += (timestep * n.vy);
        kinetic_energy += n.energy();
    }
    //damping -= 0.01;

}

class Node {
    int handle;
    int x,y;
    float mass;
    float vx = 0.0, vy = 0.0;
    boolean pinned;
    Node(int h) {
	handle = h;
	x = random(width);
	y = random(height);
	mass=1.0;
	pinned = false;
    }

    float energy() {
	/* v^2 * mass */
	return (this.vx*this.vx + this.vy*this.vy)*this.mass
    }

    String toString() {
	String s = "Node " + this.handle + " v=" + this.vx +","+ this.vy;
	return s;

    }
}

class Link {
    int handle;
    Node[] outgoing;

    Link(Node n1, Node n2){
	outgoing = new Nodes[2];
	outgoing[0] = n1;
	outgoing[1] = n2;

    }


    Link(var data)
    {
        handle = data.handle;
        outgoing = new Nodes[data.outgoing.length];
        for (var i = 0;i<data.outgoing.length;i++)
        {
            node_uuid = data.outgoing[i];
            outgoing[i] = nodes[node_uuid];
        }
    }
}
