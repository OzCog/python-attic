Remaining items to check:

#1 - Determine why Control-C doesn't work when the API is running

#2 - How do you add requirements to the "Project Requirements" like PyCharm is suggesting?

Dependencies:
sudo easy_install Flask
sudo easy_install -U mock
sudo easy_install flask-restful
sudo easy_install six

Notes for cosmist.org:
the cython build directory has to be in the PYTHONPATH
sys.path.extend(['/home/cosmo/opencog/build/opencog/cython'])

Optional:
sudo easy_install requests

#3 - Documentation:
Document how to access the API (using curl or Python 'request' or JavaScript (...)) - or just refactor the test cases into the requests library or JavaScript

#4 - Packaging:
****add dependencies to ocpkg - line 164 of ocpkg, how to add, if we're using easy_install
detect dependency existence in cmake

What will happen if you try to load the .conf file on a system that doens't have the prereqs? I could test by removing one of them, and running the cogserver.

#5 - check if the truth value type enumeration is complete

#6 - Make sure the different documentations of the files refer to the new clientexample

done:
add docstrings to the restapi.py for opencog shell
cleanup the docstrings so that the request and response each have strongly typed descriptions, and an example is provided for both,
cleanup the formatting of the JSON in the docstrings


Done:
Check Stack Overflow:
@todo should the POST method require an {'atom': [stuff]} object that contains the rest of the stuff? - NO
@todo should responses always be encapsulated in an object like DeleteAtomResponse? - NO, but you could add type info...
@todo when retrieving one entity, should you return a list type or a unary type, and should it have the same response name as a list type from the list api? 'atoms' or 'atom'?
 - varies depending on who I look at
--> these don't have to be finished...

Checking edge cases:
@todo see if the atomspace throws when giving weird values as tv or av updates - it doesn't - should validation happen both in the API and in the library?



Possible:
@todo use named tuples in the parsing
Search by incoming or outgoing set
Sort results by STI

"""
Testing:

import json
from opencog.atomspace import *
from requests import *

# GET
#  LIST
g = get('http://localhost:5000/api/v1.0/atoms')
print json.dumps(g.json(), indent=2)

#  ONE ATOM
g = get('http://localhost:5000/api/v1.0/atoms/1')
print json.dumps(g.json(), indent=2)

@todo: UPDATE THIS WITH OUTGOING SET examples

# POST
payload = {'type': 'ConceptNode', 'name': 'ugly_frog'}
headers = {'content-type': 'application/json'}
r = post('http://localhost:5000/api/v1.0/atoms/', data=json.dumps(payload), headers=headers)
print json.dumps(r.json(), indent=2)


truthvalue = {'type': 'simple', 'details': {'strength': 0.8, 'count': 0.2}}
payload = {'type': 'ConceptNode', 'name': 'ugly_frog_prince4', 'truthvalue': truthvalue}
headers = {'content-type': 'application/json'}
r = post('http://localhost:5000/api/v1.0/atoms', data=json.dumps(payload), headers=headers)
print json.dumps(r.json(), indent=2)


# PUT
g = get('http://localhost:5000/api/v1.0/atoms/1')
print json.dumps(g.json(), indent=4)
truthvalue = {'type': 'simple', 'details': {'strength': 0.6, 'count': 0.5}}
payload = {'truthvalue': truthvalue, 'attentionvalue': {'sti': 9, 'lti': 2}}
p = put('http://localhost:5000/api/v1.0/atoms/1', data=json.dumps(payload), headers=headers)
print json.dumps(p.json(), indent=4)
g = get('http://localhost:5000/api/v1.0/atoms/1')
print json.dumps(g.json(), indent=4)


"""